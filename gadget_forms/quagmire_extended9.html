<!-- Quagmire worksheet with crib dragging, in javascript -->
<!-- allow periods up to 36 -->
<!-- extended version, has double chaining/rectangle filling button -->
<!-- extended version 2, includes frequency information -->
<!-- version 3 allows multiple crib entries  -->
<!-- version 4 allows additional key column moves  -->
<!-- version 5 allows storing work in browser's local disk storage  -->
<!-- version 6 edits instructions instructions  -->
<!-- version 7 adds word list -->
<!--- version 8 adds undo-redo --->
<!--- version 9 adds get maximum chain option -->
<HTML>
<!-- written by BION -->
<HEAD>
<link rel="shortcut icon" href="Bicon16_alt2.ico">  
<TITLE> Quagmire Worksheet with Extensions </TITLE>
<!-- load word_list array -->
<script type="text/javascript" src="bigword.js">
</script>

<script type="text/javascript">

var code,code_array,crib_pos,cribtext;
var symbols="abcdefghijklmnopqrstuvwxyz-?"
var c_symbols="ABCDEFGHIJKLMNOPQRSTUVWXYZ-?"
var digits="0123456789";
var period_row = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ";
val_letter_selected=0;
var fire_fox=!document.all;
var dobj, solving_flag =0;
var asize = 10;
var line_len = 90;
var crib_entered=0;
var pair_line_limit=28;
var last_cell,numb_repeats;
var period, data;
var old_xlation;
var pair_setup=0;
var cpos;
var q3_flag;

//try associative array for key
var quag_key = new Array();
var inv_key = new Array();
var plain_key = new Array();
var columns_selected = new Array();
var inv_code_key = new Array(); // for double chaining, inverse position within code keys
var saved_key = new Array();
var saved_plain_key = new Array();
var freq = new Array();

// multiple crib entries
var temp_key = new Array();
var temp_plain_key = new Array();
var keep_key_flag=0;

// trie stuff
var EMPTY = -1;
var END_OF_WORD_INDEX = 26;
var trie = new Array();
var max_trie_index;
var alpha = "abcdefghijklmnopqrstuvwxyz";
var fitting_words = new Array();
var numb_fitting_words;
var fitting_strings = new Array();
var numb_fitting_strings;
var TOO_MANY_WORDS = 1000;

// undo and redo routines and variables

var undo_array = []; // for quag key
var redo_array = [];
var undo_index = 0;
var redo_index = 0;

var undo_array2 = []; // for plain key
var redo_array2 = [];


function do_undo(){
    var i,j;

    if (undo_index == 0) return;
    redo_array[redo_index] = [];
    redo_array2[redo_index] = [];
	for (i=0;i<=period;i++) for (j=0;j<26;j++) 
		redo_array[redo_index][c_symbols.charAt(j)+period_row.charAt(i)] = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
    for (i=0;i<26;i++)
        redo_array2[redo_index][i] =plain_key[ i ];        
	
    redo_index++;
    undo_index--;    
	for (i=0;i<=period;i++) for (j=0;j<26;j++) 
		quag_key[c_symbols.charAt(j)+period_row.charAt(i)] = undo_array[undo_index][ c_symbols.charAt(j)+period_row.charAt(i) ];
    for (i=0;i<26;i++)
        plain_key[i] = undo_array2[undo_index][i];
    document.getElementById('redo_button').disabled = false;
    restore_original();

}
function do_redo(){
    var i,j;
    
    if (redo_index == 0)
        return;
    redo_index--;
    undo_index++;
	for (i=0;i<=period;i++) for (j=0;j<26;j++) 
		quag_key[c_symbols.charAt(j)+period_row.charAt(i)] = redo_array[redo_index][ c_symbols.charAt(j)+period_row.charAt(i) ];
    for (i=0;i<26;i++)
        plain_key[i] = redo_array2[redo_index][i];
    restore_original();
}

function update_undo(){
    var i,j;

    undo_array[undo_index] = [];
    undo_array2[undo_index] = [];   
	for (i=0;i<=period;i++) for (j=0;j<26;j++) 
		undo_array[undo_index][c_symbols.charAt(j)+period_row.charAt(i)] = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
    for (i=0;i<26;i++)
        undo_array2[undo_index][i] =plain_key[ i ];        
    undo_index++;
    redo_index = 0;

}


function new_trie_element(indx){
	var i;
	
	trie[indx] = new Array();
	for ( i=0;i<26;i++)
		trie[indx][i] = EMPTY;
	trie[indx][END_OF_WORD_INDEX] = 0;
}

function insert_word(wrd){
	var i,j,c,n;
	var current_index,next_index;

	c = wrd.charAt(0);
	n = alpha.indexOf(c);
	if ( n == -1) return;
	current_index = n;
	if (wrd.length == 1){
		trie[n][END_OF_WORD_INDEX] = 1;
		return;
	}
	for (i=1;i<wrd.length;i++){
		c = wrd.charAt(i);
		n = alpha.indexOf(c);
		if ( n == -1) continue; // skip dashes and apostophes, if they haven't already been removed
		next_index = n;
		if (trie[current_index][next_index] == EMPTY){
			new_trie_element(max_trie_index);
			trie[current_index][next_index] = max_trie_index;
			max_trie_index++;
		}
		current_index = trie[current_index][next_index];
	}
	trie[current_index][END_OF_WORD_INDEX] = 1;
}

function make_trie(){ // both forward and reverse
	var i;
	
	for (i=0;i<26*2;i++)
		new_trie_element(i);
	max_trie_index = 26;
	for (i in word_list) {
		insert_word(word_list[i]);
	}

}

function trie_initialize(){
	var str,n;
	
	make_trie();
	n = word_list.length;
	str = "loaded "+n+" words using "+max_trie_index+" trie elements";
	//document.getElementById('cipher_place').value = str;		
	//alert(str);
}

function get_trie_index(str){ // get index of last trie element in the string str, already verified that str is in trie
	var i,c,current_index;
	var cnt,len;

	len = str.length;
	c = str.charAt(0);
	current_index = alpha.indexOf(c);
	cnt = 1;
	//if (cnt == len) return(current_index);
	while(cnt < len){
		c = str.charAt(cnt);		
		n =  alpha.indexOf(c);
		current_index = trie[current_index][n];		
		cnt++;
	}
	return(current_index);
}
	

function get_fitting_strings(s,len){ // get fitting strings of length len starting at position s
	// extend from previous fitting strings array if len >1
	var pos,letter,cell,c,c1;
	var temp_strings, numb_temp;
	var i,j,n,str,trie_index;
	var inv_plain = new Array(); 
    var row,c2,k,index;
	
	pos = parseInt(s); // starting position in cipher
	temp_save(); // get current key into temp_key array so you can restore key when needed
    for (i=0;i<26;i++) inv_plain[plain_key[i]]=i; //note: plain_key only changes when you swap columns in the key
	if (len == 1) { // at start, no strings stored yet
        get_inverse_key();
		cell = code_array[pos]; // code symbol
		letter = inv_key[cell]; // plaintext letter, or '-' if not filled in yet
		if (letter == '-') { // all non used starting letters are possible
            index=0;
            row = code_array[pos].charAt(1);
            c1 = code_array[pos].charAt(0);
			for (i=0;i<26;i++) { // neither key nor inverse key changed in this loop
				c = alpha.charAt(i);// is this letter unused in current row?
                n = inv_plain[symbols.indexOf(c)];
                c2 = c_symbols.charAt(n)+row;
                k = quag_key[c2];
                if ( k != '-' && k != c1) 
                    continue; // letter already taken
                fitting_strings[index++]=c;
            }
			numb_fitting_strings = index;
		}
		else { //only one letter possible, consistency already checked, any letter can begin a word, so its ok
			fitting_strings[0] = letter;
			numb_fitting_strings = 1;
		}
	}
	else { // fitting_strings array is set up
		temp_strings = new Array(); // set up next fitting strings array
		numb_temp = 0;
		for (i=0;i<numb_fitting_strings;i++){
			str = fitting_strings[i];
			trie_index = get_trie_index(str);
			if (trie[trie_index][END_OF_WORD_INDEX] == 1) // found word
				fitting_words[numb_fitting_words++] = str;
			if ( pos+len >= code_array.length) continue; // note: final entry in code array not a cipher symbol
            reset_key();
			for (j=0;j<len-1;j++){ // add letters from current fitting string to quag_key array
				c = str.charAt(j);
                row = code_array[pos+j].charAt(1);
                c1 = code_array[pos+j].charAt(0);
                n = inv_plain[symbols.indexOf(c)];
                c2 = c_symbols.charAt(n)+row;
				quag_key[c2]=c1;
			}
            get_inverse_key();            
			cell = code_array[pos+len-1]; // last code symbol
			letter = inv_key[cell]; // plaintext letter, or '-' if not filled in yet
            row = cell.charAt(1);
            c1 = cell.charAt(0);
			if ( letter == '-') { // not decoded yet;
				for (j=0;j<26;j++){
					if (trie[trie_index][j] != EMPTY) {// this is a possibility, check j for consistency
                        c = alpha.charAt(j);// is this letter unused in current row?
                        n = inv_plain[symbols.indexOf(c)];
                        c2 = c_symbols.charAt(n)+row;
                        k = quag_key[c2];
                        if ( k != '-' && k != c1) 
                            continue; // letter already taken
						temp_strings[numb_temp++] = str+c;
                    }
				}
			}
			else { // just one possibility, already consistent
				j = alpha.indexOf(letter);
				if (trie[trie_index][j] != EMPTY) // this is a possibility
					temp_strings[numb_temp++] = str+letter;
			}
		}
		// transfer new srings to fitting strings array
		numb_fitting_strings = numb_temp;
		for (i=0;i<numb_fitting_strings;i++)
			fitting_strings[i] = temp_strings[i];
	}
    reset_key(); // back to position before this function called, position was saved in temp_key   
	return(numb_fitting_strings);	
}

function show_choice(s){
	var newword,str,pos,insert_pos;
	var i,j;
    var row,c,c1,c2,n;
	var inv_plain = [];
    
	insert_pos = parseInt(s);
	pos = document.getElementById('wordlist')	
	newword = pos.options[pos.selectedIndex].text
    for (i=0;i<26;i++) inv_plain[plain_key[i]]=i; //note: plain_key only changes when you swap columns in the key    
	//str = "Choice is "+newword+"  at position "+insert_pos;
	//alert(str);
    for (j=0;j<newword.length;j++) {
		c = newword.charAt(j);
        row = code_array[insert_pos+j].charAt(1);
        c1 = code_array[insert_pos+j].charAt(0);
        n = inv_plain[symbols.indexOf(c)];
        c2 = c_symbols.charAt(n)+row;
		quag_key[c2]=c1;
	}
    // check that new word is consistent using double chaining
    if ( !extend()) {
        str = '"'+newword+'" is inconsistent with original array. Insertion canceled'
        alert(str);
        reset_key(); // quag array was inconsistent return to original key
        get_inverse_key();            
        xlate();
        restore_keyblock(0);		
    }
}
	

function undo_key(){
    reset_key();
	xlate();
	restore_keyblock(0);

}


function show_filtered_words(spos) {
	var x;
	if ( numb_fitting_words==0) {
		alert("No words in list!");
		return;
	}
	temp_save(); // so can undo
	alts=["even","odd"];
	str= 'Fitting words:<br><SELECT  size="5" id="wordlist">';
	
	state=0;
	for (var i=0;i<numb_fitting_words;i++) {
		str += '<OPTION class="'+alts[state]+'">'+fitting_words[i];
		state ^=1 ;
	}		
	str += '</select><br><input type="button" value="Insert and extend" onclick="show_choice('+spos+')">'
	str += '<input type="button" value="Undo" onclick=undo_key()>';	
    display_message(str)

}

function get_fitting_words(s){
	var str,n,m,le;
	
	numb_fitting_words = 0;
	n = get_fitting_strings(s,1);
	le = 2;
	while( n>0){
		n = get_fitting_strings(s,le);
		le++;
		if (numb_fitting_words > TOO_MANY_WORDS) break; // too many to use!
	}
	str = "There are "+numb_fitting_words+" fitting words at position: "+s+" . Show them?";
	var show_words=confirm(str);
	if ( show_words==true)
		show_filtered_words(s);
	//alert(str);
}


function save_pos(){
	var v;
	
	for (v in quag_key)
		saved_key[v] = quag_key[v];
	for (v in plain_key)
		saved_plain_key[v] = plain_key[v];
	alert("key saved");		
}

function restore_pos(){
	var do_restore,v;
	do_restore = confirm("restore key?")
		if ( do_restore == true) {
		keep_key_flag = 0;
		for (v in saved_key)
			quag_key[v] = saved_key[v];
		for (v in saved_plain_key)
			plain_key[v] = saved_plain_key[v];
		//xlate();
		//restore_keyblock(0);
		restore_original();
	}	
	
}

function temp_save(){
	var v;
	
	keep_key_flag = 1;
	for (v in quag_key)
		temp_key[v] = quag_key[v];
	for (v in plain_key)
		temp_plain_key[v] = plain_key[v];
}



function freq_color_display(){
	var i,j,s;
	
	s='';
	s += '<b>Frequency Legend:</b> ';
	for (i=0;i<5;i++){
		if (i>=4)
			co = 'white';
		else if (i==3)
			co = 'yellow';
		else if (i==2)
			co = 'pink';
		else if (i==1)
			co = 'orange';
		else
			co = 'silver'

		s = s+'<span width="75" height="75" style="border: 2px solid black; padding:2px;background:'+co+';"  >';
		s=s+'&nbsp<span width="75" height = "75" style="color:blue">';
		s=s+i+'</span> ';
		if ( i==4)
			s += '+';
		s +='</span>';
	}
	s=s+'&nbsp <br>';	
	document.getElementById('freq_legend').innerHTML= s;	
}	


function check_rectangle(tl,tr,bl,br){
	//tl = top left coordinate, tr = top right, bl = bottom left, br = bottom right
	//return number of empty corners, plus extra info for those with 1 or 0 empty corners
	var numb_empty,utl,utr,ubl,ubr,uc;
	
	numb_empty = 0;
	utl = quag_key[tl];
	if ( utl =='-'){
		numb_empty++;
		uc = tl;
	}
	utr = quag_key[tr];
	if ( utr =='-'){
		numb_empty++;
		uc = tr;
	}
	ubl = quag_key[bl];
	if ( ubl =='-'){
		numb_empty++;
		uc = bl;
	}
	ubr = quag_key[br];
	if ( ubr =='-'){
		numb_empty++;
		uc = br;
	}
	if (numb_empty >1) // no more processing required on this rectangle
		return( [numb_empty]);
	if (numb_empty == 0) //all corners filled in
		return( [0,utl,utr,ubl,ubr]);
	//OK, exactly 1 corner missing, return known letters in order: same row,same column, diagonally opposite
	if (uc == tl)
		return( [1,uc,utr,ubl,ubr]);
	if (uc == tr)
		return( [1,uc,utl,ubr,ubl]);
	if (uc == bl)
		return( [1,uc,ubr,utl,utr]);
	return( [1,uc,ubl,utr,utl]);
}

function fill_rectangle(one_missing,filled){//one_missing has 1 missing corner, filled has all corners
	var uc,sr,sc,tl,tr,bl,br,diag;
	
	uc = one_missing[0]; // coordinate to fill in, example: B3
	sr = one_missing[1]; //	letter in same row as empty corner
	sc = one_missing[2];  //letter in same column as empty corner
	diag = one_missing[3]; // letter diagonally opposite
	tl = filled[0];// top left letter
	tr = filled[1] ;//top right letter
	bl = filled[2] ;//bottom left letter
	br = filled[3] ;//bottom right letter
	if (sr == tr && sc == bl && diag == br){
		quag_key[uc] = tl;
		return(1);
	}
	if (sr == tl && sc == br && diag == bl){
		quag_key[uc ] = tr;
		return(1);
	}
	if (sr == br && sc == tl && diag == tr){
		quag_key[uc] = bl;
		return(1);
	}
	if (sr == bl && sc == tr && diag == tl){
		quag_key[uc] = br;
		return(1);
	}
	//relation still true if you swap rows and columns, so add more matches!		
	if (sr == bl && sc == tr && diag == br){
		quag_key[uc] = tl;
		return(1);
	}
	if( sr == br && sc == tl && diag == bl){
		quag_key[uc] = tr;
		return(1);
	}
	if (sr == tl && sc == br && diag == tr){
		quag_key[uc] = bl;
		return(1);
	}
	if (sr == tr && sc == bl && diag == tl){
		quag_key[uc] = br;
		return(1);
	}
	return(0);
}
	

function fill_in_rectangles(){
	var trow,lcol,brow,rcol,tl,tr,bl,br,x, change_flag,n,n1,r,r1;
	period = parseInt(document.ciphertext.period_entry.value);	
	var list_miss = new Array();
	var list_full = new Array();
	var loop_limit;
	
	if (q3_flag)
		loop_limit = period;
	else
		loop_limit = period-1;
		
	change_flag = 0;
	for (trow = 0;trow<loop_limit;trow++)
		for (lcol = 0;lcol<25;lcol++)
			for (brow = trow+1;brow<loop_limit+1;brow++)
				for (rcol = lcol+1;rcol<26;rcol++) {
					tl =  c_symbols.charAt(lcol)+period_row.charAt(trow);
					tr =  c_symbols.charAt(rcol)+period_row.charAt(trow);
					bl =  c_symbols.charAt(lcol)+period_row.charAt(brow);
					br =  c_symbols.charAt(rcol)+period_row.charAt(brow);
					x = check_rectangle(tl,tr,bl,br);
					if (x[0] == 0)
						list_full.push( x.slice(1) );
					else if (x[0] == 1)
						list_miss.push(x.slice(1));
		}
		//alert("made lists");
		for (n in list_miss){
			r = list_miss[n];
			if (quag_key[ r[0] ] != '-') // filled in earlier in loop
				continue;
			for ( n1 in list_full){
				r1 = list_full[n1];
				if (fill_rectangle(r,r1) >0){
					change_flag++;
					break;
				}
			}
		}
		return(change_flag);	
}

function complete_the_squares(){
	var change_flag,r1,c1,i1,r2,c2,i2,r3,c3,i3,r4,c4,i4,c5,base,s;
	period = parseInt(document.ciphertext.period_entry.value);	
	// quag_key[] is upper case letter, inv_key[] is lower case letter
	// example index for quag_key or inv_key is, say, A2.
	var b_end,b_start;
	
	if ( q3_flag){
		b_start = period;
		b_end = period+1;
	}
	else {
		b_start = 0;
		b_end = period;
	}
	change_flag = 0;
	for (base=0;base<b_end;base++){
		for (r1=0;r1<period;r1++){
			if (r1==base) continue;
			for (c1=0;c1<26;c1++){
				if (q3_flag)
					//i1 =  c_symbols.charAt(c1);
					i1 = inv_code_key[ c_symbols.charAt(c1)+period_row.charAt(period) ].toUpperCase();
				else 
					i1 = inv_code_key[ c_symbols.charAt(c1)+period_row.charAt(base) ].toUpperCase();
				if ( i1 == '-') continue;				
				c2 = quag_key[i1+period_row.charAt(r1) ];
				if ( c2 != '-'){
					for ( r2=0; r2<period;r2++) {
						if (r1==r2 || r2 == base) continue;
						// vertical extension
						i3 = inv_code_key[c_symbols.charAt(c1)+period_row.charAt(r2) ].toUpperCase();
						if ( i3 != '-'){
							c4 = quag_key[i3+period_row.charAt(r1) ];
							if ( c4 != '-'){
								if (q3_flag)
									//i4 = c4;
									i4 = inv_code_key[ c4+period_row.charAt(period) ].toUpperCase();
								else 
									i4 = inv_code_key[ c4+period_row.charAt(base) ].toUpperCase();
								if ( i4 != '-'){
									c5 = quag_key[i4+period_row.charAt(r2) ];
									if (c5 != '-' && c5 != c2){
										s = "Quag array inconsistent at "+c5+" and "+c2;
										alert(s);
										return(-1);
									}
									quag_key[i4+period_row.charAt(r2) ] = c2;
									inv_code_key[c2+period_row.charAt(r2) ] = i4.toLowerCase();
									if ( c5 == '-') change_flag++;
								}
							}
						}
						// horizontal extension
						if (q3_flag)
							//i2 = c2;
							i2 = inv_code_key[c2+period_row.charAt(period) ].toUpperCase();
						else
							i2 = inv_code_key[c2+period_row.charAt(base) ].toUpperCase();
						if ( i2 == '-') continue;
						c4 = quag_key[i2+period_row.charAt(r2) ];
						if ( c4 != '-') {
							i3 = inv_code_key[c4+period_row.charAt(r1) ].toUpperCase();
							if ( i3 != '-'){
								if (q3_flag)
									//c3 = i3;
									c3 = quag_key[i3+period_row.charAt(period)];
								else
									c3 = quag_key[i3+period_row.charAt(base)];
								if ( c3 != '-') {
									c5 = quag_key[i1+period_row.charAt(r2)];
									if ( c5 != '-' && c5 != c3){
										s = "Quag array not consistent at "+c5+" and "+c3;
										alert(s);
										return(-1);
									}
									quag_key[i1+period_row.charAt(r2) ] = c3;
									inv_code_key[c3+period_row.charAt(r2) ] = i1.toLowerCase();
									if ( c5 == '-') change_flag++;	
								}
							}
						}	
					}
				}
			}
		}
	}
	return (change_flag);
}
									

function extend(){
	var s,c,chain_flag,rect_flag;
	var flag, total_changes;
	
	// get inverse code key, don't  use regular inverse key in case columns were swapped
	period = parseInt(document.ciphertext.period_entry.value);	
	for (i=0;i<period;i++) for (j=0;j<26;j++) {
		inv_code_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = '-';
	}
	for (i=0;i<period;i++) for (j=0;j<26;j++) {
		if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-')
		  inv_code_key[quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]+period_row.charAt(i) ] 
		  	= symbols.charAt( j );
	}


	if (document.ciphertext.chain.checked)
		chain_flag = true;
	else
		chain_flag = false;
	if (document.ciphertext.rect_fill.checked)
		rect_flag = true;
	else
		rect_flag = false;
	if (document.ciphertext.q3.checked)
		q3_flag = true;
	else
		q3_flag = false;
		
	if (q3_flag) // add fixed row at bottom
		for (j=0;j<26;j++){
			quag_key[ c_symbols.charAt(j)+period_row.charAt(period) ] = c_symbols.charAt(plain_key[j]);
		    inv_code_key[c_symbols.charAt(plain_key[j])+period_row.charAt(period)  ] = symbols.charAt( j );
	}

	flag=1;
	total_changes = 0;
	while(flag !=0) {
		if (chain_flag){
			flag = complete_the_squares();
            if (flag == -1) // array was inconsistent
                return(false);
			total_changes += flag;
			while (flag !=0){
				flag = complete_the_squares();
                if (flag == -1) // array was inconsistent
                    return(false);
				total_changes += flag;
			}
		}
		if (rect_flag) {
			flag = fill_in_rectangles();
			total_changes += flag;
			for (i=0;i<period;i++) for (j=0;j<26;j++) {
				if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-')
				  inv_code_key[quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]+period_row.charAt(i) ] 
				  	= symbols.charAt( j );
            }
		}
	}
	s  = "there were "+total_changes+" additions to the key table";
	alert(s);
	//xlate();
	//restore_keyblock(0);
	restore_original();
    return(true);
}	

function do_extend(){
    var str;
    
    temp_save(); // in case we need to undo extension
    if (!extend()){
        str = ' Inconsistent with original array. Extension canceled'
        alert(str);
        reset_key(); // quag array was inconsistent return to original key
        get_inverse_key();            
        xlate();
        restore_keyblock(0);		
    }
}

function reset_key() {
    var i,j;
    
	if (keep_key_flag==1 ) {
		for (v in temp_key)
			quag_key[v] = temp_key[v];
		for (v in temp_plain_key)
			plain_key[v] = temp_plain_key[v];
	}	
	else {	
		period = parseInt(document.ciphertext.period_entry.value);		
		for (i=0;i<=period;i++) for (j=0;j<26;j++) {
			quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = '-';
		}
		for (i=0;i<26;i++)
			plain_key[i]= i;
	}
}

function get_inverse_key() {
	period = parseInt(document.ciphertext.period_entry.value);	
	for (i=0;i<period;i++) for (j=0;j<26;j++) {
		inv_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = '-';
	}
	for (i=0;i<period;i++) for (j=0;j<26;j++) {
		if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-')
		  inv_key[quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]+period_row.charAt(i) ] 
		  	= symbols.charAt( plain_key[j] );
	}
}


function input_ok() {
	var s='Ciphertext: (Type or paste cipher into this box, then enter the period and press the ENTER key)<BR>';
	s=s+'<TEXTAREA id=cipher_place style="font-family:monospace" name=output_area rows=9 cols=90></TEXTAREA><BR>';
	
	document.getElementById('outputblock').innerHTML=s;	
    undo_index = redo_index = 0;    	
}


function setup_code_pairs() {
	data = document.ciphertext.cipher_place.value;
	if (data.length<2){
		alert("No ciphertext entered!");
		return;
	}
	data = data.toUpperCase();
	state=0;
	code = '';
	for (i=0;i<data.length;i++) {
		c = data.charAt(i);
		if ( c_symbols.indexOf(c) >-1 && c_symbols.indexOf(c)< 26) {
				code = code+c;
		code = code+period_row.charAt(state)+' ';
		if ( ++state == period) state = 0;				
		}
	}
	//solving_flag=1;
	code_array = code.split(' ');		
	old_xlation = ['-'];
	for (i = 0;i<code_array.length-1;i++)
		old_xlation[i]= '-';
	pair_setup = 1;
	document.body.style.cursor = 'crosshair';
	// get ciphertext frequencies	
	for (i=0;i<26;i++) for (j=0;j<period;j++) 
		freq[ c_symbols.charAt(i)+period_row.charAt(j) ] = 0;
	for (i in code_array)
		freq[ code_array[i] ]++;
    undo_index = redo_index = 0;            
}	

function xlate() {
	var state,str,limit,pos,pl,cnt,numb_pairs;
	if (pair_setup ==0) {
		setup_code_pairs();
	}
	get_inverse_key();
	// next 3 lines for debugging
	//s = "quag key at A1 is "+quag_key["A1"]+" ";
	//s += "inv key at D1 is "+inv_key['D1'];
	//document.debug.output_area.value= s; 		
	str='';
	//str='<style="font-family:monospace; font-size:15px;">';
	limit=pair_line_limit;
	numb_pairs=code_array.length-1;//final entry not a code pair
	if (numb_pairs<limit)
		limit = numb_pairs;
	pos=0;
	cnt=0;
	pl='';
	while (pos<numb_pairs ) {
		ce=code_array[pos];		
		str += ce+' '
		c = inv_key[ce];
		if ( old_xlation[pos] != c){
			old_xlation[pos]=c;	
			pl = pl+'<font color="red"><span class = "plain'+pos+'">'+c+'&nbsp;&nbsp;</span></font>';					
		}
		else
			pl = pl+'<span class = "plain'+pos+'">'+c+'&nbsp;&nbsp;</span>';
		//pl = pl+c+'&nbsp;&nbsp;';
		pos++;
		cnt++;
		if (cnt>=limit) {
			//str=str+'\n'+pl+'\n';
			str = str+'<br><font color="blue">'+pl+'</font><br>'
			pl='';
			cnt=0;
			if (pos+pair_line_limit>numb_pairs)
				limit = numb_pairs-pos;;
		}
	}
	//document.ciphertext.cipher_place.value=str;
	document.getElementById('outputblock').innerHTML=str;
	restore_keyblock(0);
}
	

function selectmouse(e)
{
  var fobj       = fire_fox ? e.target : event.srcElement;
  if (fobj.className.slice(1)=="key") {
    dobj = fobj;
	cpos = c_symbols.indexOf(dobj.className.charAt(0));  
	letter_selected=1;
	//reset key
	letterblock_setup();
	c=dobj.className.charAt(0);	
	s= '<span width="75" height = "75" id ="'+c+'letter" class="'+c+'key" style="color:red">'+c+'</span>';
	document.getElementById(dobj.id).innerHTML= s;
	//next 2 lines for debugging
	//s = "you clicked on "+c;
	//document.debug.output_area.value= s; 	
    return false;
  }
  else if (fobj.className.slice(2)=="keyblock" && letter_selected) {
	  keep_key_flag = 0;
	  dobj = fobj;
	  letter=c_symbols.charAt(cpos);
	  if ( letter == '?') // query doesn't apply to key table, should click on plaintext for query
	  	return
	  s= '<span width="75" height = "75" id ="'+dobj.id+'" class="'+dobj.className+'" style="color:blue">';
	  s=s+letter+'</span>';
	  document.getElementById(dobj.id).innerHTML= s;
	  letter_selected=0;
	  cell=dobj.className.slice(0,2);
	  row = dobj.className.charAt(1);
	  //update key array
      update_undo();
      document.getElementById('redo_button').disabled = true;          
	  if (letter != '-') {
	  	// if letter appears someplace else in row remove it
	  	for (i=0;i<26;i++){
		  	c = c_symbols.charAt(i)+row;
		  	if (c== cell) continue;
		  	if (quag_key[c] == letter){
			  	s= '<span width="75" height = "75" id ="'+c+'keymatrix" class="'+c+'keyblock" style="color:blue">';
	  			s=s+'-'+'</span>';
	  			document.getElementById(c+'keymatrix').innerHTML= s;
	  			quag_key[c]='-';			  	
  			}
		}
	  }
	  quag_key[ cell] = letter;	  
	  //reset letter block
	  letterblock_setup();
	  last_cell=cell;
	  //xlate();
	  restore_original(); // dump green boxes
      //next 3 lines for debugging
	  //s = "you put it in row "+row+"\n";
	  //s = s+quag_key;
	  //document.debug.output_area.value= s; 	
      return false;	  
  }
  else if (fobj.className.slice(0,5)=="plain" && letter_selected) {
	  keep_key_flag = 0;
	  dobj = fobj;
	  x = fobj.className.slice(5);
	  p_letter=c_symbols.charAt(cpos);
	  if ( p_letter == '?'){ // query, find fitting words 
	  	get_fitting_words(x);
	  	//reset letter block
	  	letterblock_setup();
	  	return;
      }
	  cell = code_array[ parseInt(x)];
	  row = cell.charAt(1);
	  letter = cell.charAt(0);
      update_undo();
      document.getElementById('redo_button').disabled = true;          
      
      //next 3 lines for debugging
	  //s = "using letter "+p_letter+" You clicked on pos "+x+" , which is below the codepair\n";
	  //s = s+code_array[ parseInt(x)];
	  //document.debug.output_area.value= s; 	
	  letter_selected=0;	
	  //remove any previous copy of the cipher letter in this row
      for (i=0;i<26;i++){
		  	c = c_symbols.charAt(i)+row;
		  	if (quag_key[c] == letter){
			  	s= '<span width="75" height = "75" id ="'+c+'keymatrix" class="'+c+'keyblock" style="color:blue">';
	  			s=s+'-'+'</span>';
	  			document.getElementById(c+'keymatrix').innerHTML= s;
	  			quag_key[c]='-';	
  	         }
      }
	  if ( p_letter != '-') {// find column with this plaintext letter and insert cipher letter there	  
	  	for (n=0;n<26;n++) 
	  		if (plain_key[n] == cpos) break;
		cell = c_symbols.charAt(n)+row;
	    quag_key[ cell] = letter;
	    s= '<span width="75" height = "75" id ="'+cell+'keymatrix" class="'+cell+'keyblock" style="color:blue">';
	    s=s+letter+'</span>';
	    document.getElementById(cell+'keymatrix').innerHTML= s;      
      }
	  //reset letter block
	  letterblock_setup();
	  last_cell=cell;
	  //xlate();
	  restore_original();
      return false;	  
	}    
  else if (fobj.className.slice(1)=="keycolumn") {	  
	  dobj = fobj;
	  cell=dobj.className.slice(0,1);
	  //update columns selected array
	  columns_selected[ cell] ^= 1;
	  if (columns_selected[ cell]==1) {
	  	s= '<span width="75" height = "75" id ="'+dobj.id+'" class="'+dobj.className+'" style="color:black">';
	  	s +='X</span>';
	   }
	  else {	   
	  	s= '<span width="75" height = "75" id ="'+dobj.id+'" class="'+dobj.className+'" style="color:green">';
	  	s +='&nbsp</span>';
	   }		  
	  document.getElementById(dobj.id).innerHTML= s;	
      //next 3 lines for debugging
	  //s = "you put it under letter "+cell+"\n";
	  //s = s+play_key;
	  //document.debug.output_area.value= s; 	
      return false;	  
  }
	  
}
document.onmousedown=selectmouse;

function letterblock_setup() {
	var s,i,c;
	
	s=''

	for (i=0;i<symbols.length;i++) {
		c = c_symbols.charAt(i);

		s = s+'<span width="75" height="75" style="border: 2px solid white;background: white;"  >';
		s=s+'&nbsp<span width="75" height = "75" id ="'+c+'letter" class="'+c+'key" style="color:blue">';
		s=s+c+'</span> </span>';
	}	
	s=s+'<br>';	
	document.getElementById('letterblock').innerHTML=s;	
	last_cell='';

}

function keyblock_setup() {
	var s,i,c;

	period = parseInt(document.ciphertext.period_entry.value);	
    s='';
	s = s+'&nbsp'+'&nbsp';
	//letters across the top
	for (i=0;i<26;i++) {
			s = s+'<span width="75" height="75" style="border: 2px solid silver;background: silver;"  >';
			s=s+'&nbsp<span width="75" height = "75" >';
			s=s+symbols.charAt( plain_key[i] )+'</span> </span>';
	}		
	s=s+'<br>';
	for (i=0;i<period;i++) {
		cr = period_row.charAt(i);
		//digit on the side
		s = s+cr+'&nbsp';
		//row of cells
		for (j=0;j<26;j++) {
			cc=c_symbols.charAt(j);
			c = cc+cr;
			s = s+'<span width="75" height="75" style="border: 2px solid black;background: white;"  >';
			s=s+'&nbsp<span width="75" height = "75" id ="'+c+'keymatrix" class="'+c+'keyblock" style="color:blue">';
			s=s+'-'+'</span> </span>';
		}
		s=s+'&nbsp <br>';	
	}	
	s=s+'<br>';	
	document.getElementById('keyblock').innerHTML=s;	

}

function restore_keyblock(flag) { // if flag ==1 include green selection boxes
	var s,i,c,co,v,j,c2;

	period = parseInt(document.ciphertext.period_entry.value);	
	s='';
	s = s+'&nbsp'+'&nbsp';
	//letters across the top
	for (i=0;i<26;i++) {
			s = s+'<span width="75" height="75" style="border: 2px solid silver;background: silver;"  >';
			s=s+'&nbsp<span width="75" height = "75" >';
			s=s+symbols.charAt( plain_key[i] )+'</span> </span>';
	}		
	s=s+'<br>';
	for (i=0;i<period;i++) {
		cr = period_row.charAt(i);
		//digit on the side
		s = s+cr+'&nbsp';
		//row of cells
		for (j=0;j<26;j++) {
			cc=c_symbols.charAt(j);
			c = cc+cr;
			v = quag_key[c];
			c2 = v+cr;	
			if (freq[ c2 ]>=4)
				co = 'white';
			else if (freq[ c2 ]==3)
				co = 'yellow';
			else if (freq[ c2 ]==2)
				co = 'pink';
			else if (freq[ c2 ]==1)
				co = 'orange';
			else
				co = 'silver'
			
			s = s+'<span width="75" height="75" style="border: 2px solid black;background:'+co+';"  >';
			s=s+'&nbsp<span width="75" height = "75" id ="'+c+'keymatrix" class="'+c+'keyblock" style="color:blue">';
			s=s+v+'</span> </span>';
		}
		s=s+'&nbsp <br>';	
	}	
	if (flag) {//put in green column boxes
		s = s+'&nbsp'+'&nbsp';
		// green selection boxes
		for (i=0;i<26;i++) {
				c = c_symbols.charAt(i);
				s = s+'<span width="75" height="75" style="border: 2px solid black;background: green;"  >';
				s=s+'&nbsp<span width="75" height = "75" id ="'+c+'key_column" class="'+c+'keycolumn" style="color:green">';			
				s += '&nbsp</span> </span>';
				columns_selected[c] = 0;
		}		
		s=s+'&nbsp <br>';			
	} // end if flag
	
	s=s+'<br>';	
	document.getElementById('keyblock').innerHTML=s;

}


function checkEnter(e){ //e is event object passed from function invocation by entering a new period
	var characterCode //literal character code will be stored in this variable

	//next 2 lines for debuging
	//s = "you pressed a key";
	//document.debug.output_area.value= s; 	
		
	if(e && e.which){ //if which property of event object is supported (NN4)
		e = e
		characterCode = e.which //character code is contained in NN4's which property
	}
	else{
		e = event
		characterCode = e.keyCode //character code is contained in IE's keyCode property
	}
	
	if(characterCode == 13){ //reset period
		//next 2 lines for debugging
		period = parseInt(document.ciphertext.period_entry.value);		
		//s = "you pressed enter for period"+period;
		//document.debug.output_area.value= s; 	
		s = '<br>Period: <input type = text name=period_entry value =' +period+' size = 3 onKeyPress="checkEnter(event)">'
		document.getElementById('periodblock').innerHTML=s;			
		start_over();
		xlate();
		return false
	}
	else{
		return true
	}

}



function start_over() {
	if (pair_setup==0) {
		code = document.ciphertext.cipher_place.value;
	}
	keep_key_flag = 0;
	reset_key();
	letterblock_setup()
	keyblock_setup()
//	input_ok();
	document.ciphertext.cipher_place.value=code;
	xlate();
    undo_index = redo_index = 0;  
    document.getElementById('redo_button').disabled = true;    
	//solving_flag=0;
}
	

function redo() {
	do_erase = confirm("Erase the current cipher?")
	if ( do_erase == true) {
		keep_key_flag = 0;
		show_swap();
		reset_key();
		letterblock_setup()
		keyblock_setup()
		input_ok();
		document.ciphertext.cipher_place.value='';
		//solving_flag=0;
		crib_entered=0;
		pair_setup=0;
	}	
}	

function ck_crib_pos() {
	var c,pr,k,r,c1,c2,i,n;
	var inv_plain = new Array();
	
	//also set up quag_key and keyblock
	//for speed, check consistency first
	for (i=0;i<26;i++) inv_plain[plain_key[i]]=i;
	reset_key();
	get_inverse_key();
	for (i=0;i<cribtext.length;i++) {
		c = cribtext.charAt(i);
		pr =code_array[crib_pos+i];
		k = inv_key[pr];
		if ( k != '-' && k != c) {
			/* for speed,only reset at end, if not found!
			reset_key();
			keyblock_setup();	
			*/
			return(0);
		}
		inv_key[code_array[crib_pos+i]]=c;
		r = code_array[crib_pos+i].charAt(1);
		c1 = code_array[crib_pos+i].charAt(0);
		//c2 = c.toUpperCase() + r;
		n = inv_plain[symbols.indexOf(c)];
		c2 = c_symbols.charAt(n)+r;
		k = quag_key[c2];
		if ( k != '-' && k != c1) {
			return(0);
		}		
		quag_key[c2] = c1;
	}
	//it's consistent, update keyblock and screen
	keyblock_setup();
	for (i=0;i<cribtext.length;i++) {
		c = cribtext.charAt(i);
		c = c.toUpperCase();
		pr =code_array[crib_pos+i];
		c1 = pr.charAt(0);
		r = pr.charAt(1);
		pr = c+r;
        s= '<span width="75" height = "75" id ="'+pr+'keymatrix" class="'+pr+'keyblock" style="color:blue">';
	    s=s+c1+'</span>';
	    document.getElementById(pr+'keymatrix').innerHTML= s;
	}
	return(1); //OK at crib_pos!
}	


function drag_right() {
	if (crib_entered==0) {
		drag_crib();
		return;
	}
	not_found=1;	
	crib_pos++;
	if (crib_pos>=code_array.length-cribtext.length+1)
		crib_pos=0;
	while(crib_pos< code_array.length-cribtext.length+1) {
		if ( ck_crib_pos() ) {
			not_found=0;
			break; // OK!
		}
		crib_pos++;
	}
	if ( not_found ){
		reset_key();
		keyblock_setup();	
	}	
	//fill in plaintext
	show_swap();	
	xlate();
}

function drag_left(){
	if (crib_entered==0) {
		drag_crib();
		return;
	}	
	not_found=1;	
	crib_pos--;
	if (crib_pos<0)
		crib_pos=code_array.length-cribtext.length;
	while(crib_pos>=0) {
		if ( ck_crib_pos() ) {
			not_found=0;
			break; // OK!
		}
		crib_pos--;
	}
	if ( not_found ){
		reset_key();
		keyblock_setup();	
	}	
	//fill in plaintext
	show_swap();	
	xlate();
}

function drag_crib() {
	var flag;
	var crib= prompt('Enter crib');
	if (crib==' ' || crib==null)
		return;


	if (pair_setup ==0) {
		setup_code_pairs();
	}
	flag = 0;
	for (i=0;i<code_array.length-1;i++)
		if(old_xlation[i] != '-') {
			flag = 1;
			break;
	}
	if (flag){
		ck=confirm('Include current key table?');
		if (ck == true)
			temp_save();
		else
			keep_key_flag = 0;
	}
	
	cribtext='';
	crib = crib.toLowerCase();	
	for (i=0;i<crib.length;i++) {
		c = crib.charAt(i);
		if (symbols.indexOf(c) !=-1 ) {//allow '-' chars in crib!
			cribtext = cribtext+c;
		}
	}
	crib_pos=0;
	not_found=1;
	while(crib_pos< code_array.length-cribtext.length+1) {
		if ( ck_crib_pos() ) {
			not_found=0;
			break; // OK!
		}
		crib_pos++;
	}
	if ( not_found ){
		reset_key();
		keyblock_setup();	
	}
	//fill in plaintext
	show_swap();
	xlate();
	crib_entered=1;
	//solving_flag = 1;
}


function redirect() {
	window.location="quagmire_lowres.html";
}

function screen_check() {
	if (screen.width <1000) {
		redirect();
	}
	//make sure browser size is maximized
	top.window.moveTo(0,0); 
	if (!fire_fox) 
	    top.window.resizeTo(screen.availWidth,screen.availHeight);
	else if (document.layers || document.getElementById){ 
	   if (top.window.outerHeight < screen.availHeight || top.window.outerWidth < 
			screen.availWidth) {
	      top.window.outerHeight = top.screen.availHeight; 
	      top.window.outerWidth = top.screen.availWidth; 
	   } 
	} 
}

function show_swap() {
	var str;
	
	str = '<INPUT onclick=setup_swap(); type=button value="change column order in key table" >';
	document.getElementById('swapblock').innerHTML= str;	
}

function do_swap(){
	var i,ccnt, col1,col2,r,i1,i2,n,c;
	
	ccnt = 0
	for (i=0;i<26;i++) {
		c = c_symbols.charAt(i);
		if (columns_selected[c]==1) {
			if (ccnt==0) {
				col1=c;
				i1 = i;
			}
			else if ( ccnt ==1 ){
				col2=c;
				i2=i;
			}
			ccnt += 1;
		}
	}
	if (ccnt>2) {
			alert("Too many columns selected!")
			return
	}
	if (ccnt<2) {
			alert("Select a PAIR of columns!")
			return
	}	
	if ( ccnt ==2) { //swap columns col1 and col2
        update_undo();
		// swap columns in key table
		for (i=0;i<period;i++) {
			r = period_row.charAt(i);
			c = quag_key[col1+r];
			quag_key[col1+r] = quag_key[col2+r];
			quag_key[col2+r]=c;
		}
		n = plain_key[i1];
		plain_key[i1]=plain_key[i2];
		plain_key[i2]=n;
	}
		
	xlate();
	//restore_original();
	restore_keyblock(1);	
}

function restore_original(){
	show_swap();
	restore_keyblock(0);
	xlate();

}

function setup_swap() {
	str='Select 1 or 2 columns by clicking their green boxes. ';
	str += 'Then click desired action: ';
	str += '<input type="button" value="Swap" onclick=do_swap()>';		
	str += '<input type="button" value="<- column(s) left" onclick=shift_key_columns_left()>';		
	str += '<input type="button" value="column(s) right ->" onclick=shift_key_columns_right()>';			
	str += '<input type="button" value="clear Xs" onclick=restore_keyblock(1)>';				
	str += '&nbsp&nbsp<input type="button" value="Close" onclick=restore_original()>';	
	document.getElementById('swapblock').innerHTML= str;
	restore_keyblock(1);	
}


function shift_key_columns_left(){
	var i,ccnt, col1,col2,r,i1,i2,n,c,j1,j2,c1,c2;
	
	ccnt = 0
	for (i=0;i<26;i++) {
		c = c_symbols.charAt(i);
		if (columns_selected[c]==1) {
			if (ccnt==0) {
				col1=c;
				i1 = i;
			}
			else if ( ccnt ==1 ){
				col2=c;
				i2=i;
			}
			ccnt += 1;
		}
	}
	if (ccnt==1) {// move just one column
		col2=col1;
		i2=i1;
		ccnt++;
	}
	if (ccnt>2) {
			alert("Too many columns selected!")
			return
	}
	if (ccnt<2) {
			alert("No column selected!!")
			return
	}	
	if ( ccnt ==2) { //shift columns between col1 and col2 to the left
		for (j1=i1;j1<=i2;j1++) {
			j2 = (25+j1)%26; // column to left of j1
			c1 = c_symbols.charAt(j1);			
			c2 = c_symbols.charAt(j2);			
			for (i=0;i<period;i++) {
				r = period_row.charAt(i);
				c = quag_key[c1+r];
				quag_key[c1+r] = quag_key[c2+r];
				quag_key[c2+r]=c;
			}
			n = plain_key[j1];
			plain_key[j1]=plain_key[j2];
			plain_key[j2]=n;
		}
	}
		
	xlate();
	//restore_original();
	restore_keyblock(1);

	// reset selection so can move again with one click
	c1= c_symbols.charAt((25+i1)%26);
	columns_selected[c1]=1;
	c2= c_symbols.charAt((25+i2)%26);
	columns_selected[c2]=1;	
	document.getElementById(c1+'key_column').style.color = "black";
	document.getElementById(c1+'key_column').innerText= "X"	;
	document.getElementById(c2+'key_column').style.color = "black";
	document.getElementById(c2+'key_column').innerText= "X"	;


}

function shift_key_columns_right(){
	var i,ccnt, col1,col2,r,i1,i2,n,c,j1,j2,c1,c2;
	
	ccnt = 0
	for (i=0;i<26;i++) {
		c = c_symbols.charAt(i);
		if (columns_selected[c]==1) {
			if (ccnt==0) {
				col1=c;
				i1 = i;
			}
			else if ( ccnt ==1 ){
				col2=c;
				i2=i;
			}
			ccnt += 1;
		}
	}
	if (ccnt==1) {// move just one column
		col2=col1;
		i2=i1;
		ccnt++;
	}
	if (ccnt>2) {
			alert("Too many columns selected!")
			return
	}
	if (ccnt<2) {
			alert("No column selected!!")
			return
	}	
	if ( ccnt ==2) { //shift columns between col1 and col2 to the right
		for (j1=i2;j1>=i1;j1--) {
			j2 = (1+j1)%26; // column to right of j1
			c1 = c_symbols.charAt(j1);			
			c2 = c_symbols.charAt(j2);			
			for (i=0;i<period;i++) {
				r = period_row.charAt(i);
				c = quag_key[c1+r];
				quag_key[c1+r] = quag_key[c2+r];
				quag_key[c2+r]=c;
			}
			n = plain_key[j1];
			plain_key[j1]=plain_key[j2];
			plain_key[j2]=n;
		}
	}
		
	xlate();
	//restore_original();
	restore_keyblock(1);

	// reset selection so can move again with one click
	c1= c_symbols.charAt((1+i1)%26);
	columns_selected[c1]=1;
	c2= c_symbols.charAt((1+i2)%26);
	columns_selected[c2]=1;	
	document.getElementById(c1+'key_column').style.color = "black";
	document.getElementById(c1+'key_column').innerText= "X"	;
	document.getElementById(c2+'key_column').style.color = "black";
	document.getElementById(c2+'key_column').innerText= "X"	;


}

function save_to_disk(){
	var i,j, str;
	
	period = parseInt(document.ciphertext.period_entry.value);			
	if (typeof(localStorage) == 'undefined' ) {
		alert('Your browser does not support HTML5 localStorage. Try Chrome.');
	} 
	else {
		try {
			localStorage.setItem("quagmire.cipher", data); //saves to the database, “key”, “value”
			localStorage.setItem("quagmire.period", period);
		} catch (e) {
			if (e == QUOTA_EXCEEDED_ERR) {
			alert('Quota exceeded!'); //data wasn’t successfully saved due to quota exceed so throw an error
			}
		}
	}
	str = '';
	for (i=0;i<=period;i++) for (j=0;j<26;j++) {
		str += quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
	}
	localStorage.setItem("quagmire.key", str);
	str = '';
	for (i=0;i<26;i++) {
		str += plain_key[i];
		if (plain_key[i]<10)
			str += ' ';
	}
	localStorage.setItem("quagmire.plain.key", str);		
	alert("Work saved on disk");

}

function get_from_disk(){
	var s,i,j,k;

	data = localStorage.getItem("quagmire.cipher");
	if (data == undefined){
		alert("No cipher stored");
		return
	}
	keep_key_flag = 0;
	show_swap();
	reset_key();
	letterblock_setup()
	keyblock_setup()
	input_ok();
	document.ciphertext.cipher_place.value=data;
	solving_flag=0;
	crib_entered=0;
	pair_setup=0;
	period = parseInt(localStorage.getItem("quagmire.period"));
	s = '<br>Period: <input type = text name=period_entry value =' +period+' size = 3 onKeyPress="checkEnter(event)">'
	document.getElementById('periodblock').innerHTML=s;			
	start_over();
	xlate();
	s = localStorage.getItem("quagmire.key");
	k=0;
	for (i=0;i<=period;i++) for (j=0;j<26;j++) {
		quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = s.charAt(k);
		k++;
	}
	s = localStorage.getItem("quagmire.plain.key");	
	for (i=0;i<26;i++)
		plain_key[i] = parseInt(s.slice(2*i,2*i+2));
	restore_original();
}

function clear_disk(){
	localStorage.removeItem("quagmire.cipher");
	localStorage.removeItem("quagmire.period");
	localStorage.removeItem("quagmire.key");	
	localStorage.removeItem("quagmire.plain.key");		
	alert("work cleared from disk");
}

/*
function instructions(){
    var s;

    s="Step by step instructions:<br>";
    s += "(1) Paste cipher into cipher box. <br>";
    s += "(2) Enter the period and press the enter key.<br>";
    s += "(3) After pressing the enter key, wait for the display to be updated with correct <br>";
    s += "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number of rows in the key table. <br>";
    s += "(4) Now you may click the crib button and enter a crib.<br>";
    s += "(5) Drag crib right or left with arrow buttons.";
    display_message(s);
}
*/

function display_message(message){
	var s;
	
	s = '<span id="m_display">';
	s += message;
	s += '<br><br><center><input value="Close" onclick="hide_message()" type="button"></center>';
	s += '</span>';
	document.getElementById('cm_display').innerHTML=s;
	document.getElementById('m_display').style.visibility="visible";
}

function hide_message(){
	document.getElementById('m_display').style.visibility="hidden";
    document.getElementById('m_display').style.zIndex = -1; // so won't interfere with letterblock    
}

// max chain routines

function do_max_chain(){
    var s, ch,max_ch,max_len;
    var row,n;
    var max_ch2, ch2, max_len2;
    var i,j,c,base;
    
    
	// get inverse code key, don't  use regular inverse key in case columns were swapped
	period = parseInt(document.ciphertext.period_entry.value);	
	for (i=0;i<period;i++) for (j=0;j<26;j++) {
		inv_code_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = '-';
	}
	for (i=0;i<period;i++) for (j=0;j<26;j++) {
		if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-')
		  inv_code_key[quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]+period_row.charAt(i) ] 
		  	= symbols.charAt( j );
	}
	if (q3_flag) // add fixed row at bottom
		for (j=0;j<26;j++){
			quag_key[ c_symbols.charAt(j)+period_row.charAt(period) ] = c_symbols.charAt(plain_key[j]);
		    inv_code_key[c_symbols.charAt(plain_key[j])+period_row.charAt(period)  ] = symbols.charAt( j );
	}
    
    max_len = 0;
    for (base = 0;base<period;base++){
        for (row = 0; row<period;row++){
            if (!q3_flag && row== base) continue;
            for (n=0;n<26;n++){
                ch = get_chain(n,row,base);
                if ( ch.length > max_len){
                    max_len = ch.length;
                    max_ch = ch;
                }
            }
        }
        if (q3_flag) break;
    }
    s = "max chain has length "+max_len+":<br>";
    if (max_len ==25){
        for (n=0;n<26;n++){
            if (max_ch.indexOf(c_symbols.charAt(n)) != -1)
                continue;
            max_ch[25] = c_symbols.charAt(n);
            max_len++;
            break;
        }
        //s += " (added missing letter "+ max_ch[25]+ " at end)<br>";
    }
    for (n=0;n<max_len;n++)
        s += max_ch[n];
    if (max_len == 26){
        s +='<br>Decimations:'
        s += decimate_chain(max_ch);
    }
    // don't check for two 13-link chains because there will be plenty of odd shifts.
    //alert(s);
    display_message(s);
}

function get_chain(start,row,base){
    var c,cs,cn,n;
    
    
    cs = c_symbols.charAt(start)
    var chain = [cs];
    if (q3_flag)
        cn = inv_code_key[ cs+period_row.charAt(period) ].toUpperCase();
    else
        cn = inv_code_key[ cs+period_row.charAt(base) ].toUpperCase(); 
     if ( cn == '-') return(chain);
    c = quag_key[cn+period_row.charAt(row)];
    
    while ( c != '-' && c != cs){
        chain.push(c);
        if(q3_flag)
            cn = inv_code_key[ c+period_row.charAt(period) ].toUpperCase();
        else
            cn = inv_code_key[ c+period_row.charAt(base) ].toUpperCase();   
        if ( cn == '-') break;
        c = quag_key[cn+period_row.charAt(row)];
    }
    return(chain);
}

function decimate_chain(chain){
    var s,i,j,n;
    
    var shift = [1,3,5,7,9,11,15,17,19,21,23,25];
    s = '';
    for (j=0;j<shift.length;j++){
        n = shift[j];
        s += '<br>';
        for (i=0;i<n*26; i=i+n)
            s += chain[ i % 26 ];
    }
    return(s);
}

</script>
<style>
/* message display box */
#m_display {
	position:absolute; /* use absolute position so message is superimposed on cipher display */
	left:350px;
	top:320px;
	width:300px;
	height:350px;
	background: #EEEEEE;
	color: #000;
	border:3px ridge black;
	padding:10px;
    font-weight:normal;
	visibility:hidden;	

}

option.even {background-color:#909090;color:#ffffff;}
option.odd {background-color:#999999;color:#00008b;}
select {width:150px; font-family:monospace;}

</style>

</HEAD>
<BODY bgcolor="Silver">
<center><span style="font-weight:bold;">Quagmire Worksheet with Extensions</span></center><br>
<Form name=ciphertext>
<!-- mark space for cipher and plaintext -->
<div id="outputblock"
style="overflow:auto; font-family:monospace; font-size: 15px; height:200px; margin-right:100px; padding: 10px; background:white;">
Ciphertext: (Type or paste cipher into this box, then enter the period and press the ENTER key)<BR>
<TEXTAREA id=cipher_place style="font-family:monospace" name=output_area rows=9 cols=90></TEXTAREA><BR>
</div>
<!-- place to enter period -->
<span id="periodblock">
<br>
<span style="font-weight:bold;">Enter Period=></span>
<input type = text name=period_entry value = "2" size = 3 onKeyPress="checkEnter(event)">
</span>
<INPUT onclick=drag_crib(); type=button value="crib" >
<INPUT onclick=drag_left(); type=button value="<-" >
<INPUT onclick=drag_right(); type=button value="->" >
<INPUT onclick=do_undo(); type=button value="undo" >
<INPUT onclick=do_redo(); type=button value="redo" id="redo_button" disabled>
<span id="crib_repeats">
&nbsp
</span>

<!---------
 &nbsp &nbsp  &nbsp &nbsp  &nbsp &nbsp 
<INPUT onclick=start_over(); type=button value="start over" >
--------->
 
<INPUT onclick=redo(); type=button value="clear" >
<span  style="border:2px solid black; padding:10px; background:yellow;">
<INPUT onclick=do_extend(); type=button value="extend" >
<input type="checkbox" checked name="chain" > Double chain
<input type="checkbox" name="rect_fill" > Rectangle fill
<input type="checkbox" name="q3" > Quag 3
&nbsp;&nbsp;&nbsp;
<input onclick="do_max_chain()" type=button value="Max chain" >

</span>
<!--
&nbsp;
<INPUT onclick=instructions(); type=button value="instructions" >
-->
</form>



<br>
<!----  container for message display box  --->	
<div id = "cm_display" >
</div>	


Click on one of the blue symbols below , then click on a cell in the key table or beneath a cipher pair in the box above. 
(? symbol for possible words)<BR>
<!-- mark off space for letter block -->
<div id="letterblock" class="letter_block"
style="font-family:monospace; font-size: 15px; cursor: crosshair; border: 3px ridge black; 
	margin-right:20px; padding:10px">
</div>
<BR>
Key Table:
<span id="freq_legend" style = "float:right; padding:5px;">
</span>
<br>
<br>
<!-- mark off space for key block -->
<div id="keyblock" class="key_block" style="font-family:monospace; font-size: 15px; cursor: crosshair; padding:10px">
</div>

<!-- mark off space for swap -->
<div id="swapblock">
</div>
<INPUT onclick=save_to_disk(); type=button value="save work to disk" >
<INPUT onclick=get_from_disk(); type=button value="retrieve work from disk" >
<INPUT onclick=clear_disk(); type=button value="clear work from disk" >

<script type="text/javascript">
//screen_check();
reset_key();
letterblock_setup();
keyblock_setup();
show_swap();
freq_color_display();
trie_initialize();
</script>


<!---------
<Form name=debug>
<BR><TEXTAREA id=output_place styLe="font-family:monospace" name=output_area rows=2 cols=90></TEXTAREA><BR>
</Form>
---------->

</BODY>
</HTML>
