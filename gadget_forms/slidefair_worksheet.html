<!-- Quagmire worksheet with crib dragging, in javascript -->
<!-- Quagmire worksheet with crib dragging, in javascript -->
<!-- allow periods up to 36 -->
<!-- extended version, has double chaining/rectangle filling button -->
<!-- extended version 2, includes frequency information -->
<!-- version 3 allows multiple crib entries  -->
<!-- version 4 allows additional key column moves  -->
<!-- version 5 allows storing work in browser's local disk storage  -->
<!-- version 6 edits instructions instructions  -->
<!-- version 7 adds word list -->
<!-- version 8 adds undo-redo -->
<!--- version 9 adds get maximum chain option -->
<!-- added vig family keyblock extend -->
<!-- split off vig family from quagmire -->
<!-- change vig family to slidefair -->
<HTML>
<!-- written by BION -->
<HEAD>
<link rel="shortcut icon" href="Bicon16_alt2.ico">  
<TITLE> Slidefair Worksheet </TITLE>
<!-- load word_list array -->

<script type="text/javascript">

var code,code_array,crib_pos,cribtext;
var symbols="abcdefghijklmnopqrstuvwxyz-"
var c_symbols="ABCDEFGHIJKLMNOPQRSTUVWXYZ-"
var digits="0123456789";
var period_row = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ";
val_letter_selected=0;
var fire_fox=!document.all;
var dobj, solving_flag =0;
var asize = 10;
var line_len = 90;
var crib_entered=0;
var pair_line_limit=28;
var last_cell,numb_repeats;
var period, data;
var old_xlation;
var pair_setup=0;
var cpos;
var q3_flag;

//try associative array for key
var quag_key = new Array();
var inv_key = new Array();
var plain_key = new Array();
var columns_selected = new Array();
var inv_code_key = new Array(); // for double chaining, inverse position within code keys
var saved_key = new Array();
var saved_plain_key = new Array();
var freq = new Array();

// multiple crib entries
var temp_key = new Array();
var temp_plain_key = new Array();
var keep_key_flag=0;

// trie stuff
var EMPTY = -1;
var END_OF_WORD_INDEX = 26;
var trie = new Array();
var max_trie_index;
var alpha = "abcdefghijklmnopqrstuvwxyz";
var fitting_words = new Array();
var numb_fitting_words;
var fitting_strings = new Array();
var numb_fitting_strings;
var TOO_MANY_WORDS = 1000;

// undo and redo routines and variables

var undo_array = []; // for quag key
var redo_array = [];
var undo_index = 0;
var redo_index = 0;

var undo_array2 = []; // for plain key
var redo_array2 = [];


function do_undo(){
    var i,j;

    if (undo_index == 0) return;
    redo_array[redo_index] = [];
    redo_array2[redo_index] = [];
	for (i=0;i<=period;i++) for (j=0;j<26;j++)
		redo_array[redo_index][c_symbols.charAt(j)+period_row.charAt(i)] = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
    for (i=0;i<26;i++)
        redo_array2[redo_index][i] =plain_key[ i ];
	
    redo_index++;
    undo_index--;
	for (i=0;i<=period;i++) for (j=0;j<26;j++)
		quag_key[c_symbols.charAt(j)+period_row.charAt(i)] = undo_array[undo_index][ c_symbols.charAt(j)+period_row.charAt(i) ];
    for (i=0;i<26;i++)
        plain_key[i] = undo_array2[undo_index][i];
    document.getElementById('redo_button').disabled = false;
    restore_original();
    temp_save();

}
function do_redo(){
    var i,j;
    
    if (redo_index == 0)
        return;
    redo_index--;
    undo_index++;
	for (i=0;i<=period;i++) for (j=0;j<26;j++)
		quag_key[c_symbols.charAt(j)+period_row.charAt(i)] = redo_array[redo_index][ c_symbols.charAt(j)+period_row.charAt(i) ];
    for (i=0;i<26;i++)
        plain_key[i] = redo_array2[redo_index][i];
    restore_original();
    temp_save();
}

function update_undo(){
    var i,j;

    undo_array[undo_index] = [];
    undo_array2[undo_index] = [];
	for (i=0;i<=period;i++) for (j=0;j<26;j++)
		undo_array[undo_index][c_symbols.charAt(j)+period_row.charAt(i)] = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
    for (i=0;i<26;i++)
        undo_array2[undo_index][i] =plain_key[ i ];
    undo_index++;
    redo_index = 0;

}



function save_pos(){
	var v;
	
	for (v in quag_key)
		saved_key[v] = quag_key[v];
	for (v in plain_key)
		saved_plain_key[v] = plain_key[v];
	alert("key saved");
}

function restore_pos(){
	var do_restore,v;
	do_restore = confirm("restore key?")
		if ( do_restore == true) {
		keep_key_flag = 0;
		for (v in saved_key)
			quag_key[v] = saved_key[v];
		for (v in saved_plain_key)
			plain_key[v] = saved_plain_key[v];
		//xlate();
		//restore_keyblock(0);
		restore_original();
	}
	
}

function temp_save(){
	var v;
	
	keep_key_flag = 1;
	for (v in quag_key)
		temp_key[v] = quag_key[v];
	for (v in plain_key)
		temp_plain_key[v] = plain_key[v];
}



function freq_color_display(){
	var i,j,s;
	
	s='';
	s += '<b>Frequency Legend:</b> ';
	for (i=0;i<5;i++){
		if (i>=4)
			co = 'white';
		else if (i==3)
			co = 'yellow';
		else if (i==2)
			co = 'pink';
		else if (i==1)
			co = 'orange';
		else
			co = 'silver'

		s = s+'<span width="75" height="75" style="border: 2px solid black; padding:2px;background:'+co+';"  >';
		s=s+'&nbsp<span width="75" height = "75" style="color:blue">';
		s=s+i+'</span> ';
		if ( i==4)
			s += '+';
		s +='</span>';
	}
	s=s+'&nbsp <br>';
	document.getElementById('freq_legend').innerHTML= s;
}

function extend(){
	var s,c,chain_flag,rect_flag;
	var flag, total_changes,i,j;

    if (document.getElementById('bea_type').checked)
        flag = bea_extend();
    else
        flag = vig_extend();
    return(flag);
        
}

function do_extend(){
    var str;
    
    update_undo();
    temp_save(); // in case we need to undo extension
    if (!extend()){
        str = ' Inconsistent with original array. Extension canceled'
        alert(str);
        reset_key(); // quag array was inconsistent return to original key
        get_inverse_key();
        xlate();
        restore_keyblock(0);
    }
}

function reset_key() {
    var i,j;
    
	if (keep_key_flag==1 ) {
		for (v in temp_key)
			quag_key[v] = temp_key[v];
		for (v in temp_plain_key)
			plain_key[v] = temp_plain_key[v];
	}
	else {
		period = parseInt(document.ciphertext.period_entry.value);
		for (i=0;i<=period;i++) for (j=0;j<26;j++) {
			quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = '-';
		}
		for (i=0;i<26;i++)
			plain_key[i]= i;
	}
}

function get_inverse_key() {
	period = parseInt(document.ciphertext.period_entry.value);
	for (i=0;i<period;i++) for (j=0;j<26;j++) {
		inv_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = '-';
	}
	for (i=0;i<period;i++) for (j=0;j<26;j++) {
		if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-')
		  inv_key[quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]+period_row.charAt(i) ]
		  	= symbols.charAt( plain_key[j] );
	}
}


function input_ok() {
	var s='Ciphertext: (Put cipher into this box, select cipher type, then enter the period and press the ENTER key)<BR>';
	s=s+'<TEXTAREA id=cipher_place style="font-family:monospace" name=output_area rows=9 cols=90></TEXTAREA><BR>';
	
	document.getElementById('outputblock').innerHTML=s;
    undo_index = redo_index = 0;
}


function setup_code_pairs() {
    var temp;
	data = document.ciphertext.cipher_place.value;
	if (data.length<2){
		alert("No ciphertext entered!");
		return;
	}
	data = data.toUpperCase();
    temp = '';
	for (i=0;i<data.length;i++) {
		c = data.charAt(i);
		if ( c_symbols.indexOf(c) >-1 && c_symbols.indexOf(c)< 26) 
				temp = temp+c;
    }
    if ( (temp.length%2) != 0){
        alert("Odd number of cipher letters!");
        return;
    }
	state=0;
	code = '';
	for (i=0;i<temp.length;i=i+2) {
		c = temp.charAt(i);
		if ( c_symbols.indexOf(c) >-1 && c_symbols.indexOf(c)< 26) 
				code = code+c;
		code = code+period_row.charAt(state)+' ';
		c = temp.charAt(i+1);
		if ( c_symbols.indexOf(c) >-1 && c_symbols.indexOf(c)< 26) 
				code = code+c;
		code = code+period_row.charAt(state)+' ';
        
		if ( ++state == period) state = 0;
		
	}
	//solving_flag=1;
	code_array = code.split(' ');
	old_xlation = ['-'];
	for (i = 0;i<code_array.length-1;i++)
		old_xlation[i]= '-';
	pair_setup = 1;
	document.body.style.cursor = 'crosshair';
	// get ciphertext frequencies
	for (i=0;i<26;i++) for (j=0;j<period;j++)
		freq[ c_symbols.charAt(i)+period_row.charAt(j) ] = 0;
	for (i in code_array)
		freq[ code_array[i] ]++;
    undo_index = redo_index = 0;
}

function xlate() {
	var state,str,limit,pos,pl,cnt,numb_pairs;
    var c,c1,ce,n,c_next;
	if (pair_setup ==0) {
		setup_code_pairs();
	}
	get_inverse_key();
	// next 3 lines for debugging
	//s = "quag key at A1 is "+quag_key["A1"]+" ";
	//s += "inv key at D1 is "+inv_key['D1'];
	//document.debug.output_area.value= s;
	str='';
	//str='<style="font-family:monospace; font-size:15px;">';
	limit=pair_line_limit;
	numb_pairs=code_array.length-1;//final entry not a code pair
	if (numb_pairs<limit)
		limit = numb_pairs;
	pos=0;
	cnt=0;
	pl='';
	while (pos<numb_pairs ) {
		ce=code_array[pos];
		str += ce+' '
        if ( (pos%2) == 0){
            c_next = '-';
            c = inv_key[ code_array[pos+1] ];
            c1 = ce.charAt(0).toLowerCase();
            if ( c == c1){ // vertical pair
                n = symbols.indexOf(c);
                c = symbols.charAt( (25+n)%26 ); // move one letter left
                c_next = quag_key[ c.toUpperCase()+ce.charAt(1) ].toLowerCase();
            }
        }
        else {
            if ( c_next != '-')
                c = c_next;
            else
                c = quag_key[ code_array[pos-1] ].toLowerCase();            
        }
		if ( old_xlation[pos] != c){
			old_xlation[pos]=c;
			pl = pl+'<font color="red"><span class = "plain'+pos+'">'+c+'&nbsp;&nbsp;</span></font>';
		}
		else
			pl = pl+'<span class = "plain'+pos+'">'+c+'&nbsp;&nbsp;</span>';
		//pl = pl+c+'&nbsp;&nbsp;';
		pos++;
		cnt++;
		if (cnt>=limit) {
			//str=str+'\n'+pl+'\n';
			str = str+'<br><font color="blue">'+pl+'</font><br>'
			pl='';
			cnt=0;
			if (pos+pair_line_limit>numb_pairs)
				limit = numb_pairs-pos;;
		}
	}
	//document.ciphertext.cipher_place.value=str;
	document.getElementById('outputblock').innerHTML=str;
    if (document.getElementById('bea_type').checked)
        bea_swap();
    else
        vig_swap(); // may need to swap pairs in key that resulted from vertical pair encryption.
	restore_keyblock(0);
}
	

function selectmouse(e)
{
  var fobj       = fire_fox ? e.target : event.srcElement;
  var col_letter, col_index, new_cell;
  var parity, cipher_pos, temp;
  if (fobj.className.slice(1)=="key") {
    dobj = fobj;
	cpos = c_symbols.indexOf(dobj.className.charAt(0));
	letter_selected=1;
	//reset key
	letterblock_setup();
	c=dobj.className.charAt(0);
	s= '<span width="75" height = "75" id ="'+c+'letter" class="'+c+'key" style="color:red">'+c+'</span>';
	document.getElementById(dobj.id).innerHTML= s;
	//next 2 lines for debugging
	//s = "you clicked on "+c;
	//document.debug.output_area.value= s;
    return false;
  }
  else if (fobj.className.slice(2)=="keyblock" && letter_selected) {
	  keep_key_flag = 0;
	  dobj = fobj;
	  letter=c_symbols.charAt(cpos);
	  s= '<span width="75" height = "75" id ="'+dobj.id+'" class="'+dobj.className+'" style="color:blue">';
	  s=s+letter+'</span>';
	  document.getElementById(dobj.id).innerHTML= s;
	  letter_selected=0;
	  cell=dobj.className.slice(0,2);
	  row = dobj.className.charAt(1);
	  //update key array
      update_undo();
      document.getElementById('redo_button').disabled = true;      
	  if (letter != '-') {
	  	// if letter appears someplace else in row remove it
	  	for (i=0;i<26;i++){
		  	c = c_symbols.charAt(i)+row;
		  	if (c== cell) continue;
		  	if (quag_key[c] == letter){
			  	s= '<span width="75" height = "75" id ="'+c+'keymatrix" class="'+c+'keyblock" style="color:blue">';
	  			s=s+'-'+'</span>';
	  			document.getElementById(c+'keymatrix').innerHTML= s;
	  			quag_key[c]='-';
  			}
		}
	  }
	  quag_key[ cell] = letter;
	  //reset letter block
	  letterblock_setup();
	  last_cell=cell;
	  //xlate();
	  restore_original(); // dump green boxes
      //next 3 lines for debugging
	  //s = "you put it in row "+row+"\n";
	  //s = s+quag_key;
	  //document.debug.output_area.value= s;
      return false;
  }
  else if (fobj.className.slice(0,5)=="plain" && letter_selected) {
	  keep_key_flag = 0;
	  dobj = fobj;
	  x = fobj.className.slice(5);
	  p_letter=c_symbols.charAt(cpos);
      update_undo();
      document.getElementById('redo_button').disabled = true;      
      cipher_pos = parseInt(x);
      parity = cipher_pos % 2;
      if ( parity==0){
        cell = code_array[ cipher_pos+1];
        row = cell.charAt(1);
        letter = cell.charAt(0); // cipher letter
      }
      else {
        cell = code_array[ cipher_pos-1];
        row = cell.charAt(1);
        letter = cell.charAt(0); // cipher letter, swap with plain letter!
        temp = letter;
        letter  = p_letter;
        p_letter = temp;
        cpos = c_symbols.indexOf(p_letter);
      }
      //next 3 lines for debugging
	  //s = "using letter "+p_letter+" You clicked on pos "+x+" , which is below the codepair\n";
	  //s = s+code_array[ parseInt(x)];
	  //document.debug.output_area.value= s;
	  letter_selected=0;
	  //remove any previous copy of the cipher letter in this row
      for (i=0;i<26;i++){
		  	c = c_symbols.charAt(i)+row;
		  	if (quag_key[c] == letter){
			  	s= '<span width="75" height = "75" id ="'+c+'keymatrix" class="'+c+'keyblock" style="color:blue">';
	  			s=s+'-'+'</span>';
	  			document.getElementById(c+'keymatrix').innerHTML= s;
	  			quag_key[c]='-';
  	         }
      }
	  if ( p_letter != '-') {// find column with this plaintext letter and insert cipher letter there
	  	for (n=0;n<26;n++)
	  		if (plain_key[n] == cpos) break;
		cell = c_symbols.charAt(n)+row;
	    quag_key[ cell] = letter;
	    s= '<span width="75" height = "75" id ="'+cell+'keymatrix" class="'+cell+'keyblock" style="color:blue">';
	    s=s+letter+'</span>';
	    document.getElementById(cell+'keymatrix').innerHTML= s;
        
      }
	  //reset letter block
	  letterblock_setup();
	  last_cell=cell;
	  //xlate();
	  restore_original();
      return false;
	}	  
}
document.onmousedown=selectmouse;

function letterblock_setup() {
	var s,i,c;
	
	s=''

	for (i=0;i<symbols.length;i++) {
		c = c_symbols.charAt(i);

		s = s+'<span width="75" height="75" style="border: 2px solid white;background: white;"  >';
		s=s+'&nbsp<span width="75" height = "75" id ="'+c+'letter" class="'+c+'key" style="color:blue">';
		s=s+c+'</span> </span>';
	}
	s=s+'<br>';
	document.getElementById('letterblock').innerHTML=s;
	last_cell='';

}

function keyblock_setup() {
	var s,i,c;

	period = parseInt(document.ciphertext.period_entry.value);
    s='';
	s = s+'&nbsp'+'&nbsp';
	//letters across the top
	for (i=0;i<26;i++) {
			s = s+'<span width="75" height="75" style="border: 2px solid silver;background: silver;"  >';
			s=s+'&nbsp<span width="75" height = "75" >';
			s=s+symbols.charAt( plain_key[i] )+'</span> </span>';
	}
	s=s+'<br>';
	for (i=0;i<period;i++) {
		cr = period_row.charAt(i);
		//digit on the side
		s = s+cr+'&nbsp';
		//row of cells
		for (j=0;j<26;j++) {
			cc=c_symbols.charAt(j);
			c = cc+cr;
			s = s+'<span width="75" height="75" style="border: 2px solid black;background: white;"  >';
			s=s+'&nbsp<span width="75" height = "75" id ="'+c+'keymatrix" class="'+c+'keyblock" style="color:blue">';
			s=s+'-'+'</span> </span>';
		}
		s=s+'&nbsp <br>';
	}
	s=s+'<br>';
	document.getElementById('keyblock').innerHTML=s;

}

function restore_keyblock(flag) { // flag always 0 for Vig family
	var s,i,c,co,v,j,c2;

	period = parseInt(document.ciphertext.period_entry.value);
	s='';
	s = s+'&nbsp'+'&nbsp';
	//letters across the top
	for (i=0;i<26;i++) {
			s = s+'<span width="75" height="75" style="border: 2px solid silver;background: silver;"  >';
			s=s+'&nbsp<span width="75" height = "75" >';
			s=s+symbols.charAt( plain_key[i] )+'</span> </span>';
	}
	s=s+'<br>';
	for (i=0;i<period;i++) {
		cr = period_row.charAt(i);
		//digit on the side
		s = s+cr+'&nbsp';
		//row of cells
		for (j=0;j<26;j++) {
			cc=c_symbols.charAt(j);
			c = cc+cr;
			v = quag_key[c];
			c2 = v+cr;
			if (freq[ c2 ]>=4)
				co = 'white';
			else if (freq[ c2 ]==3)
				co = 'yellow';
			else if (freq[ c2 ]==2)
				co = 'pink';
			else if (freq[ c2 ]==1)
				co = 'orange';
			else
				co = 'silver'
			
			s = s+'<span width="75" height="75" style="border: 2px solid black;background:'+co+';"  >';
			s=s+'&nbsp<span width="75" height = "75" id ="'+c+'keymatrix" class="'+c+'keyblock" style="color:blue">';
			s=s+v+'</span> </span>';
		}
		s=s+'&nbsp <br>';
	}
	
	s=s+'<br>';
	document.getElementById('keyblock').innerHTML=s;

}


function checkEnter(e){ //e is event object passed from function invocation by entering a new period
	var characterCode //literal character code will be stored in this variable

	//next 2 lines for debuging
	//s = "you pressed a key";
	//document.debug.output_area.value= s;
		
	if(e && e.which){ //if which property of event object is supported (NN4)
		e = e
		characterCode = e.which //character code is contained in NN4's which property
	}
	else{
		e = event
		characterCode = e.keyCode //character code is contained in IE's keyCode property
	}
	
	if(characterCode == 13){ //reset period
		//next 2 lines for debugging
		period = parseInt(document.ciphertext.period_entry.value);
		//s = "you pressed enter for period"+period;
		//document.debug.output_area.value= s;
		s = '<br>Period: <input type = text name=period_entry value =' +period+' size = 3 onKeyPress="checkEnter(event)">'
		document.getElementById('periodblock').innerHTML=s;
		start_over();
		xlate();
        update_undo();
		return false
	}
	else{
		return true
	}

}



function start_over() {
	if (pair_setup==0) {
		code = document.ciphertext.cipher_place.value;
	}
	keep_key_flag = 0;
	reset_key();
	letterblock_setup()
	keyblock_setup()
//	input_ok();
	document.ciphertext.cipher_place.value=code;
	xlate();
    undo_index = redo_index = 0;
    document.getElementById('redo_button').disabled = true;
	//solving_flag=0;
}
	

function redo() {
	do_erase = confirm("Erase the current cipher?")
	if ( do_erase == true) {
		keep_key_flag = 0;
		reset_key();
		letterblock_setup()
		keyblock_setup()
		input_ok();
		document.ciphertext.cipher_place.value='';
		//solving_flag=0;
		crib_entered=0;
		pair_setup=0;
	}
}



function redirect() {
	window.location="quagmire_lowres.html";
}

function screen_check() {
	if (screen.width <1000) {
		redirect();
	}
	//make sure browser size is maximized
	top.window.moveTo(0,0);
	if (!fire_fox)
	    top.window.resizeTo(screen.availWidth,screen.availHeight);
	else if (document.layers || document.getElementById){
	   if (top.window.outerHeight < screen.availHeight || top.window.outerWidth <
			screen.availWidth) {
	      top.window.outerHeight = top.screen.availHeight;
	      top.window.outerWidth = top.screen.availWidth;
	   }
	}
}

function restore_original(){
	restore_keyblock(0);
	xlate();

}


function save_to_disk(){
	var i,j, str;
	
	period = parseInt(document.ciphertext.period_entry.value);
	if (typeof(localStorage) == 'undefined' ) {
		alert('Your browser does not support HTML5 localStorage. Try Chrome.');
	}
	else {
		try {
			localStorage.setItem("slidefair.cipher", data); //saves to the database, �key�, �value�
			localStorage.setItem("slidefair.period", period);
		} catch (e) {
			if (e == QUOTA_EXCEEDED_ERR) {
			alert('Quota exceeded!'); //data wasn�t successfully saved due to quota exceed so throw an error
			}
		}
	}
	str = '';
	for (i=0;i<=period;i++) for (j=0;j<26;j++) {
		str += quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
	}
	localStorage.setItem("slidefair.key", str);
	str = '';
	for (i=0;i<26;i++) {
		str += plain_key[i];
		if (plain_key[i]<10)
			str += ' ';
	}
	localStorage.setItem("slidefair.plain.key", str);
    if (document.getElementById('vig_type').checked)
        localStorage.setItem("slidefair.c_type", "vig_type");
    else if (document.getElementById('var_type').checked)
        localStorage.setItem("slidefair.c_type", "var_type");
    else
        localStorage.setItem("slidefair.c_type", "bea_type");    
	alert("Work saved on disk");

}

function get_from_disk(){
	var s,i,j,k;

	data = localStorage.getItem("slidefair.cipher");
	if (data == undefined){
		alert("No cipher stored");
		return
	}
	keep_key_flag = 0;
	reset_key();
	letterblock_setup()
	keyblock_setup()
	input_ok();
	document.ciphertext.cipher_place.value=data;
	solving_flag=0;
	crib_entered=0;
	pair_setup=0;
	period = parseInt(localStorage.getItem("slidefair.period"));
	s = '<br>Period: <input type = text name=period_entry value =' +period+' size = 3 onKeyPress="checkEnter(event)">'
	document.getElementById('periodblock').innerHTML=s;
	start_over();
	xlate();
	s = localStorage.getItem("slidefair.key");
	k=0;
	for (i=0;i<=period;i++) for (j=0;j<26;j++) {
		quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = s.charAt(k);
		k++;
	}
	s = localStorage.getItem("slidefair.plain.key");
	for (i=0;i<26;i++)
		plain_key[i] = parseInt(s.slice(2*i,2*i+2));
    s = localStorage.getItem("slidefair.c_type");
    document.getElementById('vig_type').checked = false;
    document.getElementById('var_type').checked = false;
    //document.getElementById('por_type').checked = false;
    document.getElementById('bea_type').checked = false;
    document.getElementById(s).checked = true;
	restore_original();
}

function clear_disk(){
	localStorage.removeItem("slidefair.cipher");
	localStorage.removeItem("slidefair.period");
	localStorage.removeItem("slidefair.key");
	localStorage.removeItem("slidefair.plain.key");
	localStorage.removeItem("slidefair.c_type");    
	alert("work cleared from disk");
}


function display_message(message){
	var s;
	
	s = '<span id="m_display">';
	s += message;
	s += '<br><br><center><input value="Close" onclick="hide_message()" type="button"></center>';
	s += '</span>';
	document.getElementById('cm_display').innerHTML=s;
	document.getElementById('m_display').style.visibility="visible";
}

function hide_message(){
	document.getElementById('m_display').style.visibility="hidden";
    document.getElementById('m_display').style.zIndex = -1; // so won't interfere with letterblock
}

function vig_swap(){ // swap adjacent letters in key that are neighbors in wrong order due to vertical pair code
    var n,n1,c,c1, i,j;
	period = parseInt(document.ciphertext.period_entry.value);
    for (i=0; i<period;i++){
        for (j = 0;j<25;j++){
            c = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
            if ( c != '-'){ // check neighbor to right
                c1 = quag_key[ c_symbols.charAt(j+1)+period_row.charAt(i) ];
                if (c1 != '-'){
                    n = c_symbols.indexOf(c);
                    n1 = c_symbols.indexOf(c1);
                    if ( n1 == (n-1) || (n==0 && n1 == 25) ){ // do swap
                        quag_key[ c_symbols.charAt(j+1)+period_row.charAt(i) ] = c;
                        quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = c1;
                    }
                }
            }
        }
    }
    
}

function bea_swap(){ // swap adjacent letters in key that are neighbors in wrong order due to vertical pair code
    var n,n1,c,c1, i,j;
	period = parseInt(document.ciphertext.period_entry.value);
    for (i=0; i<period;i++){
        for (j = 0;j<25;j++){
            c = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
            if ( c != '-'){ // check neighbor to right
                c1 = quag_key[ c_symbols.charAt(j+1)+period_row.charAt(i) ];
                if (c1 != '-'){
                    n = c_symbols.indexOf(c);
                    n1 = c_symbols.indexOf(c1);
                    if ( n1 == (n+1) || (n1==0 && n == 25) ){ // do swap
                        quag_key[ c_symbols.charAt(j+1)+period_row.charAt(i) ] = c;
                        quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ] = c1;
                    }
                }
            }
        }
    }
    
}

function vig_extend(){
var i,j,k,flag,c,c_start,n_start,c1,s,c2;
//    temp_save();
	period = parseInt(document.ciphertext.period_entry.value);
// in vig family, plaintext key is 'a', so make sure plaintext row is in alphabetical order.
    for (i=0;i<26;i++)
        if (plain_key[i] != i){
            alert("Plain key not in alphabetical order!")
            return(false);
    }
// extend key block rows in alphabetical order.
    for (i=0;i<period;i++) {
        flag = false;
        for (j=0;j<26;j++) {
            if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-'){
                flag = true;
                c_start = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
                n_start = c_symbols.indexOf(c_start);
                if ( j>0){
                    // fill backwards towards 0
                    n = n_start;
                    for (k = j-1;k>=0;k--){
                        n = (25+n)%26;
                        quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ] = c_symbols.charAt(n);
                    }
                }
                
            }
            if ( flag) break;
        }
        if (!flag) continue; // empty row, go to next row
        n = n_start;
        for (k = j+1;k<26;k++){ // fill row to right, check consistency
            n = (n+1)%26;
            c = c_symbols.charAt(n)
            c1 = quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ];
            if ( c1 != '-' && c1 != c){
                c2 = i+1;
                s = "Key inconsistent! Row "+c2+" not in alphabetical order.";
                alert(s);
                // restore original key block
                reset_key(); // quag array was inconsistent return to original key
                get_inverse_key();
                xlate();
                restore_keyblock(0);
                return(false);
            }
            quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ] = c;
            
        }
    }
    restore_original();
    return(true);
}

function bea_extend(){
var i,j,k,flag,c,c_start,n_start,c1,s,c2;
//    temp_save();
	period = parseInt(document.ciphertext.period_entry.value);
// in vig family, plaintext key is 'a', so make sure plaintext row is in alphabetical order.
    for (i=0;i<26;i++)
        if (plain_key[i] != i){
            alert("Plain key not in alphabetical order!")
            return(false);
    }
// extend key block rows in reverse alphabetical order.
    for (i=0;i<period;i++) {
        flag = false;
        for (j=0;j<26;j++) {
            if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-'){
                flag = true;
                c_start = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
                n_start = c_symbols.indexOf(c_start);
                if ( j>0){
                    // fill backwards towards 0
                    n = n_start;
                    for (k = j-1;k>=0;k--){
                        //n = (25+n)%26;
                        n = (n+1)%26;
                        quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ] = c_symbols.charAt(n);
                    }
                }
                
            }
            if ( flag) break;
        }
        if (!flag) continue; // empty row, go to next row
        n = n_start;
        for (k = j+1;k<26;k++){ // fill row to right, check consistency
            //n = (n+1)%26;
            n = (25+n)%26; // fill in reverse alpha order
            c = c_symbols.charAt(n)
            c1 = quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ];
            if ( c1 != '-' && c1 != c){
                c2 = i+1;
                s = "Key inconsistent! Row "+c2+" not in reversed alphabetical order.";
                alert(s);
                // restore original key block
                reset_key(); // quag array was inconsistent return to original key
                get_inverse_key();
                xlate();
                restore_keyblock(0);
                return(false);
            }
            quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ] = c;
            
        }
    }
    restore_original();
    return(true);
}

function do_key(){
    var i,j,k,s;
    var n1,n2;
    var s1,flag,pat,result;
    if (document.getElementById('vig_type').checked){
       s = "Vigenere key: ";
       for (i=0;i<period;i++)
        s += quag_key[ c_symbols.charAt(0)+period_row.charAt(i) ];
       //alert(s);
       display_message(s);
    }
    else if (document.getElementById('bea_type').checked){
       s = "Beaufort key: ";
       for (i=0;i<period;i++)
        s += quag_key[ c_symbols.charAt(0)+period_row.charAt(i) ];
       //alert(s);
       display_message(s);
    }
     else {
        s = "Variant key: ";
        get_inverse_key();
        for (i=0;i<period;i++)
            s += inv_key[c_symbols.charAt(0)+period_row.charAt(i) ].toUpperCase();
        //alert(s);        
        display_message(s);
    }
}

function check_consistent(){
	var c,pr,k,r,c1,c2,i,n,flag,j,k;
    var c_start, n_start,n1,n2;

    // check vig family key table
    if (document.getElementById('bea_type').checked){
        for (i=0;i<period;i++) {
            flag = false;
            for (j=0;j<26;j++) {
                if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-'){
                    flag = true;
                    c_start = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
                    n_start = c_symbols.indexOf(c_start);
                    if ( j>0){
                        n = n_start;                    
                        for (k = j-1;k>=0;k--){
                            //n = (25+n)%26;
                            n = (n+1)%26;
                            quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ] = c_symbols.charAt(n);
                        }
                    }
                }
                if ( flag) break;
            }
            if (!flag) continue; // empty row, go to next row
            n = n_start;
            for (k = j+1;k<26;k++){ // fill row to right, check consistency
                //n = (n+1)%26;
                n = (25+n)%26; // fill in reverse alpha order
                c = c_symbols.charAt(n)
                c1 = quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ];
                if ( c1 != '-' && c1 != c){
                    //c2 = i+1;
                    //s = "Key inconsistent! Row "+c2+" not in reversed alphabetical order.";
                    //alert(s);
                    /*
                    // restore original key block
                    reset_key(); // quag array was inconsistent return to original key
                    get_inverse_key();
                    xlate();
                    restore_keyblock(0);
                    */
                    return(0);
                }
                quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ] = c;                
            }
        }
    
    }
    else {
        for (i=0;i<period;i++) {
            flag = false;
            for (j=0;j<26;j++) {
                if (quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ]!= '-'){
                    flag = true;
                    c_start = quag_key[ c_symbols.charAt(j)+period_row.charAt(i) ];
                    n_start = c_symbols.indexOf(c_start);
                    if ( j>0){
                        // fill backwards towards 0
                        n = n_start;
                        for (k = j-1;k>=0;k--){
                            n = (25+n)%26;
                            quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ] = c_symbols.charAt(n);
                        }
                    }
                    
                    
                }
                if ( flag) break;
            }
            if (!flag) continue; // empty row, go to next row
            n = n_start;
            for (k = j+1;k<26;k++){ // fill row to right, check consistency
                n = (n+1)%26;
                //n = (25+n)%26; // fill in reverse alpha order
                c = c_symbols.charAt(n)
                c1 = quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ];
                if ( c1 != '-' && c1 != c){
                    //c2 = i+1;
                    //s = "Key inconsistent! Row "+c2+" not in reversed alphabetical order.";
                    //alert(s);
                    /*
                    // restore original key block
                    reset_key(); // quag array was inconsistent return to original key
                    get_inverse_key();
                    xlate();
                    restore_keyblock(0);
                    */
                    return(0);
                }
                quag_key[ c_symbols.charAt(k)+period_row.charAt(i) ] = c;
            }
        }
    
    }
    return(1);
}


function ck_crib_pos() {
	var c,pr,k,r,c1,c2,i,n,flag,j,k;
    var c_start, n_start,n1,n2;
    var n3,v;
	var inv_plain = new Array();
	
	//also set up quag_key and keyblock
	//for speed, check consistency first
	for (i=0;i<26;i++) inv_plain[plain_key[i]]=i;
	keep_key_flag = 0;
	reset_key();
	get_inverse_key();
    flag = 0;
	for (i=0;i<cribtext.length;i++) {
		c = cribtext.charAt(i);
        if ( i==0 && ((crib_pos+i)%2 !=0) )
            continue;
        // check for vertical pairs
        if ( (crib_pos+i)%2 ==0 && i<cribtext.length-1){
            n = symbols.indexOf(c);
            n1 = symbols.indexOf(cribtext.charAt(i+1));
            v = code_array[crib_pos+i].charAt(0);
            n2 = c_symbols.indexOf(v);
            n3 = c_symbols.indexOf(code_array[crib_pos+i+1].charAt(0) );
            flag = 0;
            if (document.getElementById('bea_type').checked && (n+1)%26 == n2 && (26+n1-1)%26 == n3)
                flag = 1;
            else if ((n+1)%26 == n2 && (n1+1)%26 == n3)
                flag = 1;
            if ( flag){ // have vertical pair
                r = code_array[crib_pos+i].charAt(1);
                c2 = c_symbols.charAt(n)+r;
                v = c_symbols.charAt(n1);
                if ( quag_key[c2] != '-' && quag_key[c2] != v)
                    return(0);
                quag_key[c2] = v;
                if (check_consistent() == 0)
                    return(0); 
                i++; // skip next cipher letter, already accounted for
                continue;
            }
        }        
        if((crib_pos+i)%2 ==0){
            pr =code_array[crib_pos+i+1];
            k = inv_key[pr];
        }
        else{
            k = quag_key[ code_array[crib_pos+i-1] ].toLowerCase();                    
        }
		
		if ( k != '-' && k != c) {
			/* for speed,only reset at end, if not found!
			reset_key();
			keyblock_setup();
			*/
			return(0);
		}
        if((crib_pos+i)%2 ==0){
            inv_key[code_array[crib_pos+i+1]]=c;
            r = code_array[crib_pos+i+1].charAt(1);
            c1 = code_array[crib_pos+i+1].charAt(0);
            //c2 = c.toUpperCase() + r;
            n = inv_plain[symbols.indexOf(c)];
            c2 = c_symbols.charAt(n)+r;
            k = quag_key[c2];
            if ( k != '-' && k != c1) {
                return(0);
            }
            quag_key[c2] = c1;   
            /*
            if (document.getElementById('bea_type').checked)
                bea_swap();
            else
                vig_swap(); // may need to swap pairs in key that resulted from vertical pair encryption.
            */
            if (check_consistent() == 0)
                return(0);                
        }
        // don't need  to insert second letter, already inserted by row expansion.
    }
	//it's consistent, update keyblock and screen
	keyblock_setup();
	for (i=0;i<cribtext.length;i++) {
		c = cribtext.charAt(i);
		c = c.toUpperCase();
		pr =code_array[crib_pos+i];
		c1 = pr.charAt(0);
		r = pr.charAt(1);
		pr = c+r;
        s= '<span width="75" height = "75" id ="'+pr+'keymatrix" class="'+pr+'keyblock" style="color:blue">';
	    s=s+c1+'</span>';
	    document.getElementById(pr+'keymatrix').innerHTML= s;
	}
	return(1); //OK at crib_pos!
}


function drag_right() {
	if (crib_entered==0) {
		drag_crib();
		return;
	}
	not_found=1;
	crib_pos++;
	if (crib_pos>=code_array.length-cribtext.length+1)
		crib_pos=0;
	while(crib_pos< code_array.length-cribtext.length+1) {
		if ( ck_crib_pos() ) {
			not_found=0;
			break; // OK!
		}
		crib_pos++;
	}
	if ( not_found ){
		reset_key();
		keyblock_setup();
	}

	//fill in plaintext
	xlate();
	extend();
}

function drag_left(){
	if (crib_entered==0) {
		drag_crib();
		return;
	}
	not_found=1;
	crib_pos--;
	if (crib_pos<0)
		crib_pos=code_array.length-cribtext.length;
	while(crib_pos>=0) {
		if ( ck_crib_pos() ) {
			not_found=0;
			break; // OK!
		}
		crib_pos--;
	}
	if ( not_found ){
		reset_key();
		keyblock_setup();
	}

	//fill in plaintext
	xlate();
	extend();
}

function drag_crib() {
	var flag;
	var crib= prompt('Enter crib');
	if (crib==' ' || crib==null)
		return;


	if (pair_setup ==0) {
		setup_code_pairs();
	}
	flag = 0;
	for (i=0;i<code_array.length-1;i++)
		if(old_xlation[i] != '-') {
			flag = 1;
			break;
	}
	if (flag){
		ck=confirm('Include current key table?');
		if (ck == true)
			temp_save();
		else
			keep_key_flag = 0;
	}
	
	cribtext='';
	crib = crib.toLowerCase();
	for (i=0;i<crib.length;i++) {
		c = crib.charAt(i);
		if (symbols.indexOf(c) !=-1 ) {//allow '-' chars in crib!
			cribtext = cribtext+c;
		}
	}
	crib_pos=0;
	not_found=1;
	while(crib_pos< code_array.length-cribtext.length+1) {
		if ( ck_crib_pos() ) {
			not_found=0;
			break; // OK!
		}
		crib_pos++;
	}
	if ( not_found ){
		reset_key();
		keyblock_setup();
	}
	//fill in plaintext
	xlate();
	extend();
	crib_entered=1;
	//solving_flag = 1;
}


</script>
<style>
/* message display box */
#m_display {
	position:absolute; /* use absolute position so message is superimposed on cipher display */
	left:350px;
	top:320px;
	width:300px;
	height:350px;
	background: #EEEEEE;
	color: #000;
	border:3px ridge black;
	padding:10px;
    font-weight:normal;
	visibility:hidden;

}

option.even {background-color:#909090;color:#ffffff;}
option.odd {background-color:#999999;color:#00008b;}
select {width:150px; font-family:monospace;}

</style>

</HEAD>
<BODY bgcolor="Silver">
<center><span style="font-weight:bold;">Slidefair Worksheet</span></center><br>
<Form name=ciphertext>
<!-- mark space for cipher and plaintext -->
<div id="outputblock"
style="overflow:auto; font-family:monospace; font-size: 15px; height:200px; margin-right:100px; padding: 10px; background:white;">
Ciphertext: (Put cipher into this box, select cipher type, then enter the period and press the ENTER key)<BR>
<TEXTAREA id=cipher_place style="font-family:monospace" name=output_area rows=9 cols=90></TEXTAREA><BR>
</div>
<!-- place to enter period -->
<span id="periodblock">
<br>
<span style="font-weight:bold;">Enter Period=></span>
<input type = text name=period_entry value = "2" size = 3 onKeyPress="checkEnter(event)">
</span>

<INPUT onclick=drag_crib(); type=button value="crib" >
<INPUT onclick=drag_left(); type=button value="<-" >
<INPUT onclick=drag_right(); type=button value="->" >
<INPUT onclick=do_undo(); type=button value="undo" >
<INPUT onclick=do_redo(); type=button value="redo" id="redo_button" disabled>
<span id="crib_repeats">
&nbsp
</span>

<!---------
 &nbsp &nbsp  &nbsp &nbsp  &nbsp &nbsp
<INPUT onclick=start_over(); type=button value="start over" >
--------->
Type:
<input type="radio" name="r_buttons" id = "vig_type" checked> Vigenere
&nbsp;
<input type="radio" name="r_buttons" id = "var_type"> Variant
&nbsp;
 <input type="radio" name="r_buttons" id = "bea_type"> Beaufort
&nbsp;&nbsp;
<INPUT onclick=do_extend(); type=button value="Extend key" >
&nbsp;&nbsp;
<INPUT onclick=do_key(); type=button value="Show key" >

</form>



<br>
<!----  container for message display box  --->
<div id = "cm_display" >
</div>


Click on one of the blue symbols below , then click on a cell in the key table or beneath a cipher pair in the box above.
<BR>
<!-- mark off space for letter block -->
<div id="letterblock" class="letter_block"
style="font-family:monospace; font-size: 15px; cursor: crosshair; border: 3px ridge black;
	margin-right:20px; padding:10px">
</div>
<BR>
Key Table:
<span id="freq_legend" style = "float:right; padding:5px;">
</span>
<br>
<br>
<!-- mark off space for key block -->
<div id="keyblock" class="key_block" style="font-family:monospace; font-size: 15px; cursor: crosshair; padding:10px">
</div>

<!-- mark off space for swap -->
<INPUT onclick=save_to_disk(); type=button value="save work to disk" >
<INPUT onclick=get_from_disk(); type=button value="retrieve work from disk" >
<INPUT onclick=clear_disk(); type=button value="clear work from disk" >
<script type="text/javascript">
//screen_check();
reset_key();
letterblock_setup();
keyblock_setup();
freq_color_display();

</script>


<!---------
<Form name=debug>
<BR><TEXTAREA id=output_place styLe="font-family:monospace" name=output_area rows=2 cols=90></TEXTAREA><BR>
</Form>
---------->

</BODY>
</HTML>
