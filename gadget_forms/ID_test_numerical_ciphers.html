<HTML><HEAD><TITLE>Neural Net ID, Numerical ciphers</TITLE>
<link rel="shortcut icon" href="Bicon16_alt2.ico">
<META http-equiv=Content-Type content="text/html; charset=windows-1252">


<script type="text/javascript" src="shiffman_bias_weights_numerical_only.js"></script>

<SCRIPT language=JavaScript>

// does not use chi-sq test, 37 input stats only
// Daniel Shiffman
// Nature of Code: Intelligence and Learning
// https://github.com/shiffman/NOC-S17-2-Intelligence-Learning

// Based on "Make Your Own Neural Network" by Tariq Rashid
// https://github.com/makeyourownneuralnetwork/

// This is my own ridiculous Matrix implemenation
// Would probably make more sense to use math.js or something else!
class Matrix {

// Make a matrix full of zeros
constructor(rows, cols) {
  this.rows = rows;
  this.cols = cols;
  this.data = new Array(rows);
  for (var i = 0; i < this.rows; i++) {
    this.data[i] = new Array(cols);
    for (var j = 0; j < this.cols; j++) {
      this.data[i][j] = 0;
    }
  }
}

// This fills the matrix with random values
randomize() {
  for (var i = 0; i < this.rows; i++) {
    for (var j = 0; j < this.cols; j++) {
      this.data[i][j] = Math.random()*2-1;
      //this.data[i][j] = randomGaussian();
      //this.data[i][j] = random(-1, 1);
    }
  }
}

// Take the matrix and make it a 1 dimensional array
toArray() {
  // Add all the values to the array
  var arr = [];
  for (var i = 0; i < this.rows; i++) {
    for (var j = 0; j < this.cols; j++) {
      arr.push(this.data[i][j]);
    }
  }
  return arr;
}


// This transposes a matrix
// rows X cols --> cols X rows
transpose() {
  var result = new Matrix(this.cols, this.rows);
  for (var i = 0; i < result.rows; i++) {
    for (var j = 0; j < result.cols; j++) {
      result.data[i][j] = this.data[j][i];
    }
  }
  return result;
}

// This makes a copy of the matrix
copy() {
  var result = new Matrix(this.rows, this.cols);
  for (var i = 0; i < result.rows; i++) {
    for (var j = 0; j < result.cols; j++) {
      result.data[i][j] = this.data[i][j];
    }
  }
  return result;
}

/*
// This adds a single value to each element
add(other) {
  // Are we trying to add a Matrix?
  if (other instanceof Matrix) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        this.data[i][j] += other.data[i][j];
      }
    }
    // Or just a single scalar value?
  } else {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        this.data[i][j] += other;
      }
    }
  }
}
*/

// a scalar multiply
multiply(other) {
    // Or just a single scalar value?

    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        this.data[i][j] *= other;
      }
    }

}

map(fn) {

   for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        this.data[i][j] = fn(this.data[i][j]) ;
      }
    }

}


static multiply(a,b){
  if (a.cols != b.rows) {
    console.log("Incompatible matrix sizes!");
    return;
  }
  // Make a new matrix
  var result = new Matrix(a.rows, b.cols);
  for (let i = 0; i < a.rows; i++) {
    for (let j = 0; j < b.cols; j++) {
      // Sum all the rows of A times columns of B
      var sum = 0;
      for (var k = 0; k < a.cols; k++) {
        sum += a.data[i][k] * b.data[k][j];
      }
      // New value
      result.data[i][j] = sum;
    }
  }
  return result;

}

static add(a,b){
  // Make a new matrix
  var result = new Matrix(a.rows, a.cols);
  for (let i = 0; i < result.rows; i++) {
    for (let j = 0; j < result.cols; j++) {
      result.data[i][j] = a.data[i][j] + b.data[i][j];
    }
  }
  return result;

}


static fromArray(ar){
    let m = new Matrix(ar.length,1);
    for (let i = 0; i<ar.length;i++)
        m.data[i][0] = ar[i];
    return(m);
}

} // end Matrix class


class NeuralNetwork{

/*
 constructor(input_nodes,hidden_nodes,output_nodes){
    this.input_nodes = input_nodes;
    this.hidden_nodes = hidden_nodes;
    this.output_nodes = output_nodes;
    this.weights_ih = new Matrix(this.hidden_nodes,this.input_nodes);
    this.weights_ho = new Matrix(this.output_nodes,this.hidden_nodes);
    this.weights_ih.randomize();
    this.weights_ho.randomize();
    this.bias_h = new Matrix(this.hidden_nodes,1);
    this.bias_o = new Matrix(this.output_nodes,1);
    this.bias_h.randomize();
    this.bias_o.randomize();
    
 }
*/
 constructor(input_nodes,hidden_nodes,output_nodes,weights_ih,weights_ho,bias_h,bias_o){
    this.input_nodes = input_nodes;
    this.hidden_nodes = hidden_nodes;
    this.output_nodes = output_nodes;
    this.weights_ih = weights_ih;
    this.weights_ho = weights_ho
    this.bias_h = bias_h;
    this.bias_o = bias_o;
    
 }

 feedforward(input_array){
 
    // generate hidden outputs
    let inputs = Matrix.fromArray(input_array);
    let hidden = Matrix.multiply(this.weights_ih,inputs);
    //hidden.add(this.bias_h);
    hidden = Matrix.add(hidden,this.bias_h);
    hidden.map(relu);
    // generate final output
    let output = Matrix.multiply(this.weights_ho,hidden);
    //output.add(this.bias_o)
    output = Matrix.add(output,this.bias_o);
    //output.map(sigmoid);
    output.map(softmax);
    let ar = output.toArray();
    return( ar );
 }
 
 
} // end neural network class

if (!Array.prototype.indexOf) {
 Array.prototype.indexOf = function(elt /*, from*/) {
   var len = this.length;

   var from = Number(arguments[1]) || 0;
   from = (from < 0)
        ? Math.ceil(from)
        : Math.floor(from);
   if (from < 0)
     from += len;

   for (; from < len; from++)   {
     if (from in this &&
         this[from] === elt)
       return from;
   }
   return -1;
 };
}


var test_values;
var normalized_test_values;

/*
var numerical_types = { 
"Grandpre": 0,
"Grandpre10x10": 1,
"homophonic": 2,
"monomeDinome": 3,
"morbit": 4,
"nihilistSub": 5,
"NihilistSub6x6": 6,
"numberedKey": 1, // same as Grandpre10x10
"pollux": 7,
"syllabary": 8,
"tridigital": 9
}
*/

var cipher_name_normalized_order = [ "Grandpre","numberedKey","homophonic","monomeDinome","morbit","nihilistSub","NihilistSub6x6","pollux","syllabary","tridigital" ];

var display_new_stats;

function do_clear() {
	document.puzzle.ciphertext.value = ""
	document.puzzle.cipherstats.value = ""
    document.getElementById('period_entry').value = '10';
}

function neural_net_get_id(input_array){
    var i,j,k,n,c,s;
    var sum,max_out,max_index;
    let numb_outputs = 10;
    
    
   var outputs = nnet.feedforward(input_array);
    
        // get index of the max output
    max_out = 0;
    for (i=0;i<numb_outputs;i++)
        if (outputs[i]>max_out){
            max_out = outputs[i];
            max_index = i;
        }
        
    // get result in percent (softmax)
    sum = 0;
    for (i=0;i<numb_outputs;i++)
        sum += outputs[i];
    // sort in frequency order
    var freq_list = [];
    for (i=0;i<numb_outputs;i++)
        freq_list[i] = [cipher_name_normalized_order[i],outputs[i]/sum];
    freq_list.sort(function(a,b){return(b[1]-a[1])});
    return([max_index,freq_list]);
     
}

function sigmoid(x){
return( 1.0/(1.0+Math.exp(-x)) )
}

function relu(x){
    if (x<0) return(0);
    return(x);
}

function softmax(x){
    return( Math.exp(x) )
}

function neural_net_setup(){
debugger;
	let numb_inputs = 16;
    let numb_hidden = hidden_bias.length;
    let numb_outputs = 10;

    var hb = new Matrix(numb_hidden,1);
    for (i=0;i<numb_hidden;i++)
        hb.data[i][0] = hidden_bias[i][0];
        
    var ob = new Matrix(numb_outputs,1);
    for (i=0;i<numb_outputs;i++)
        ob.data[i][0] = output_bias[i][0];
    //out_str = "bias martices constructed\n";
    var iw  = new Matrix(numb_hidden,numb_inputs);
    for (i=0;i<numb_hidden;i++)
        for (j=0;j<numb_inputs;j++)
            iw.data[i][j] = input_weights[i][j]; 
    var ow  = new Matrix(numb_outputs,numb_hidden);
    for (i=0;i<numb_outputs;i++)
        for (j=0;j<numb_hidden;j++)
            ow.data[i][j] = hidden_weights[i][j]; 
    //out_str += "weight matrices constructed\n";
    
    nnet = new NeuralNetwork(numb_inputs,numb_hidden,numb_outputs,iw,ow,hb,ob);

}

// compute selected stats, under development
var test_values;
var normalized_test_values;
function lefttrim(str) { // remove leading blanks
	return str.replace(/^\s+/g, '');
}

function alltrim(str) { // remove leading and trailing blanks
	return str.replace(/^\s+|\s+$/g, '');
}

function condense_white_space(str) { // replace sequences of 1 or more space characters by single blanks
	return str.replace(/\s+/g, ' ');
}

function letters_only(str){ // remove everthing except letters
	str = str.toLowerCase();
	return str.replace(/[^a-z]/g,'');
}

function digits_only(str){ // remove everthing except digits
	str = str.toLowerCase();
	return str.replace(/[^0-9]/g,'');
}

function blanks_only(str) { // replace all non letters by blanks
	str = str.toLowerCase();
	return str.replace(/[^a-z]/g,' ');
}
function one_blank_separator(str){// return words separated by exactly one blank
		str = blanks_only(str);
		str = alltrim(str);
		str = condense_white_space(str)
		return(str);
}

var has_digits, has_hash;
var cipher_symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZ#0123456789";
var numb_symbols;
//numb_symbols = cipher_symbols.length;
numb_symbols = 10;
var max_period;


function convert_string() {
	var num_code = new Array(),i,clen,n;

	var digits = '0123456789';
	code = document.puzzle.ciphertext.value;
	//code = code.toUpperCase();
    code = code.replace(/Ø/g,'0');
	code = digits_only(code);
	clen=0;
	for (i=0;i<code.length;i++) {
		n = digits.indexOf(code.charAt(i))
		if ( n != -1){
			num_code[clen]=n;
			clen++;
		}
	}
	return num_code;
}

function get_ic(dat) {
	var sum,i,ic,l;
	var ct=new Array()
	
	for (i=0;i<numb_symbols;i++)
		ct[i]=0;
	l = dat.length;
	for (i=0;i<l;i++)
		ct[ dat[i] ] += 1
	sum = 0.0
	for (i=0;i<numb_symbols;i++)
		sum += ct[i]*(ct[i]-1)
	ic = sum/(l*(l-1));
	return( ic*1000);
}


function get_max_periodic_ic(dat) {
	var sum,i,j,l,mx,period,index,x,y,z;
	var ct=new Array()
	
	mx=0.0;

	l= dat.length;
	for (i=0;i<=max_period;i++)
		ct[i]=new Array(numb_symbols);
	for (period = 1; period <= max_period;period++) {	
		for (i=0;i<period;i++)
			for (j=0;j<numb_symbols;j++)
				ct[i][j]=0;
		index = 0;
		for (i=0;i<l;i++) {
			ct[index][ dat[i] ] += 1;
			index = (index+1)%period;
		}
		z=0.0
		for (i=0;i<period;i++) {
			x=y=0.0;
			for (j=0;j<numb_symbols;j++) {
				x += ct[i][j]*(ct[i][j]-1);
				y += ct[i][j];
			}
			if (y>1) z += x/(y*(y-1));
		}
		z = z/period;
		if (z>mx) mx = z;
	}
	return( 1000.0*mx);
}

function get_dic(dat) {
	var sum,i,ic,l;
	var ct=new Array()
	
	for (i=0;i<numb_symbols*numb_symbols;i++)
		ct[i]=0;
	l = dat.length;
	for (i=0;i<l-1;i++)
		ct[ dat[i]+numb_symbols*dat[i+1] ] += 1
	sum = 0.0
	for (i=0;i<numb_symbols*numb_symbols;i++)
		sum += ct[i]*(ct[i]-1)
	l--;
	ic = sum/(l*(l-1));
	return( ic*10000);
}

function get_even_dic(dat) {
	var sum,i,ic,l,n;
	var ct=new Array()
	
	for (i=0;i<numb_symbols*numb_symbols;i++)
		ct[i]=0;
	l = dat.length;
	n=0;
	for (i=0;i<l-1;i=i+2) {
		ct[ dat[i]+numb_symbols*dat[i+1] ] += 1
		n++;
	}
	sum = 0.0
	for (i=0;i<numb_symbols*numb_symbols;i++)
		sum += ct[i]*(ct[i]-1)
	ic = sum/(n*(n-1));
	return( ic*10000);
}

function get_LR(dat) {
	var i,j,n,l;
	var reps = new Array(11);
	
	for (i=0;i<11;i++) reps[i]=0;
	l = dat.length;
	for (i=0;i<l;i++)
		for (j=i+1;j<l;j++) {
			n=0;
			while (j+n<l && dat[i+n]==dat[j+n])
				n++;
			if ( n>10) n=10;
			reps[n]++;
		}
	return( 1000.0*Math.sqrt(reps[3])/l);
}

function calc_length_attributes(len){
    var s,s1,n;
    var test_index;
    
    test_index = 5;



    if ((len%2) == 0) {

        test_values[test_index++] = 'Y';
    }
    else {

        test_values[test_index++] = 'N';
    }




    if ((len%3) == 0) {

        test_values[test_index++] = 'Y';
    }
    else {

        test_values[test_index++] = 'N';
    }

    if ((len%5) == 0) {

        test_values[test_index++] = 'Y';
    }
    else {

        test_values[test_index++] = 'N';
    }


    if ((len%25) == 0) {

        test_values[test_index++] = 'Y';
    }
    else {

        test_values[test_index++] = 'N';
    }
}	

function get_TRI_SEP(cipher){
	var i,j,k,c,n,s;
	var max_len;
	
	var best_sep = 'none'

	var min_max_word_sep_len = 100;
	for (i=0;i<10;i++){
		max_len = get_max_len(cipher,i);
		if (max_len < min_max_word_sep_len){
			min_max_word_sep_len = max_len;
			best_sep = i;
		}
	}
	return([min_max_word_sep_len, best_sep] );
}

function get_max_len(cipher,digit){
	var i,j,k,c,n,s;
	var max_len, last_pos,dist;
	
	max_len = 0;
	last_pos = -1;
	for (i=0;i<cipher.length;i++){
		if (cipher[i] == digit){
			dist = i - last_pos;
			if ( dist == 1)// two adjacent copies of digit, can't be word separator
				return(100);
			if (dist > max_len)
				max_len = dist;
			last_pos = i;
		}
	}
	// last distance, from last position to end of cipher
	dist = cipher.length - last_pos;
	if ( dist > max_len)
		max_len = dist;
	if (max_len> 100) max_len = 100; //cap at 100
	return(max_len);
}

function get_max_even(cipher){
var i,j,c,n,s;
var max;

  max = 0;
  for (i=0;i<cipher.length;i = i+2){
    if ( max<cipher[i])
      max = cipher[i];
  }
  return(max);

}

function get_has_9(cipher){
var i,j,c,n,s;

  for (i=0;i<cipher.length;i++){
    if ( cipher[i] == 9)
      return('Y');
  }
  return('N');

}

function do_convert(la1,la2,str){
	var alpha,out_str,c,n,c1,c2,s;
    var i,la1,la2,cnt,state,let;
    var buf_len;
	
	alpha="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var digits = '0123456789';
    
    
    // make translation dictionary
    var xlate = {};
    cnt = 0;
    for (i=0;i<10;i++) {
        c = digits.charAt(i);
        if ( c==la1 || c== la2) continue;
        xlate[c] = alpha.charAt(cnt);
        s = la1+c;
        xlate[s] = alpha.charAt(cnt+8);
        s = la2+c;
        xlate[s] = alpha.charAt(cnt+16);
        cnt++;
    }
    var freq = {};
    state = 0;
	out_str="";
    c1 = '';
    cnt = 0;
    buf_len = 0;
    for (i = 0; i < str.length;i++){
        c = str.charAt(i);
        if (state == 0){
            if ( c==la1 || c == la2){
                c1 = c;
                state = 1;
            }
            else {
                let = xlate[c];
                out_str += let;
                if (let in freq)
                    freq[let]++;
                else
                    freq[let]=1;
                buf_len++;
                if ( ++cnt == 5){
                    out_str += ' ';
                    cnt = 0;
                }
            }
        }
        else {
            if ( c==la1 || c == la2){
                //alert("Two adjacent row labels!");
                return([-1,'error']);
            }
            s = c1+c;
            let = xlate[s];
            out_str += let;
            if (let in freq)
                freq[let]++;
            else
                freq[let]=1;
            buf_len++;
            if ( ++cnt == 5){
                out_str += ' ';
                cnt = 0;
            }
            state = 0;
            c1 = '';
        }
    }
    if ( c1 != '') {
        //alert("Code ends in row label!");
        return([-1,'error']);
    }
    out_str += '\n';
    var sum = 0;
    for (let in freq){
        sum += freq[let]*(freq[let]-1);
    }
    var ic = sum/(buf_len*(buf_len-1));
    ic = ic.toFixed(4); // converts to string but looks like subtraction coverts back to number again.
	
    return([ic,out_str]);
}


function get_MD_diff(code){
	var str, alpha,out_str,c,n,c1,c2,s;
    var i,la1,la2,cnt,state,code;
    var r1,r2,score,best_score;
    var best_str;
	
	alpha="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var digits = '0123456789';
    best_score = 1.000;
    out_str = '';

	best_str = 'Best MD_diff is 1.000 because no labels are possible';
    for (r1 = 0;r1<=8;r1++)
        for (r2 = r1+1;r2<=9;r2++) {
            s = do_convert(digits.charAt(r1),digits.charAt(r2),code);
            if (s[0] == -1) continue;
            score = 0.065 - s[0];
            if (score<0) score = -score;
            if (score<best_score) {
                best_score = score;
                //best_str = 'labels '+r1+r2+' ic = '+s[0]+'\n'+s[1];
				best_str = 'Best MD_diff is '+score.toFixed(4)+' for ic of '+s[0]+' and labels '+r1+r2
            }
    }
	//return(best_str);
	return(best_score.toFixed(4));
	

}

function get_nsp(dat){ // possible nihilist sub periods
    var code, code_len, state, sq_size, period,cycle,i,j,k,key,flag,pos,x,y;
    var min_per = 2;
        
     if ( (dat.length%2) != 0)  //odd length
        return('N'); // can't divide into numerical pairs
    // dat entries for '0'-'9' got from 27 to 36
   	code = [];
    code_len = 0;
    state = 0;
	for (i=0;i<dat.length;i++){
            //n = dat[i] - 27; // put into range 0-9
			n = dat[i];
            if (state == 0) {
                n1 = n;
                state = 1;
            }
            else {
                code[code_len++] = 10*n1+n;
                state = 0;
            }

	}
    sq_size = 5;
     for (period = min_per;period<= max_period;period++) {
        for (cycle = 0;cycle<period;cycle++) {
            for (j= 1;j<= sq_size;j++) {
                for (k= 1;k<= sq_size;k++) {
                    key = 10*j+k;
                    flag = 1;
                        pos = cycle;
                        while( pos<code_len) {
                            n = code[pos];
                            //if ( n<11) n += 100;
                            //n -= key;
                            n = (100+n-key)%100;                                
                            x = Math.floor(n / 10);
                            y = n % 10;
                            if ( x< 1 || x > sq_size || y<1 || y > sq_size) {
                                flag = 0;
                                 break;
                            }
                            pos += period;
                        } /* end while */
                        if ( flag )
                                break;
                } /* next k */
                if ( flag)
                        break;
            } /* next j */
            if ( !flag) {
                //printf("No possible key for period %li \n",period);
                break;
            }
        } /* next cycle */
        if ( flag)
            //printf("\tPeriod %li is possible!\n",period);
            //out_str += "Period "+period+" is possible.\n";
            return('Y');
    } /* next period */

    return('N'); // period up to max_period;

}


var pollux_calcs = function(){
// T has compressed binary Single letter - Trigraph Discrepancy values
// had to replace \ by \\
//var buffer;
var plain_text;
var buffer;
var key;
var crib_flag = false;
var buf_len;

var work_buffer=[];
var score_buffer = [];

var symbols_3 = '.-x';

var EMPTY = -1;
var END_SYMBOL = 2;
var ERROR_SYMBOL = '^';
var free_index, start0,start1;
var morse = [];
var code_len, plain_len;  
var inverse_table = []; // calculate just once to spped things up
/* codes: 0 = dot, 1 = dash ,2 = end of letter */
var m_code= [ 'e',0,2,
        't',1,2,
        'i',0,0,2,
        'a',0,1,2,
        'n',1,0,2,
        'm',1,1,2,
        's',0,0,0,2,
        'u',0,0,1,2,
        'r',0,1,0,2,
        'w',0,1,1,2,
        'd',1,0,0,2,
        'k',1,0,1,2,
        'g',1,1,0,2,
        'o',1,1,1,2,
        'h',0,0,0,0,2,
        'v',0,0,0,1,2,
        'f',0,0,1,0,2,
        'l',0,1,0,0,2,
        'p',0,1,1,0,2,
        'j',0,1,1,1,2,
        'b',1,0,0,0,2,
        'x',1,0,0,1,2,
        'c',1,0,1,0,2,
        'y',1,0,1,1,2,
        'z',1,1,0,0,2,
        'q',1,1,0,1,2,
        '1',0,1,1,1,1,2,
        '2',0,0,1,1,1,2,
        '3',0,0,0,1,1,2,
        '4',0,0,0,0,1,2,
        '5',0,0,0,0,0,2,
        '6',1,0,0,0,0,2,
        '7',1,1,0,0,0,2,
        '8',1,1,1,0,0,2,
        '9',1,1,1,1,0,2,
        '0',1,1,1,1,1,2,
        '.',1,0,1,0,1,0,2,
        ',',1,1,0,0,1,1,2,
        '?',0,1,0,1,0,1,2,
        ':',1,1,1,0,0,0,2,
        ';',1,0,1,0,1,0,2,
        '-',1,0,0,0,0,1,2,
        '/',1,0,0,1,0,2,
        '=',1,0,0,0,1,2,
         -1 ];



function initialize_morse_code(){
	var cn,nindex,i,j,k,n;
	var c;
	
	for (i=0;i<100;i++){
		morse[i] = {};
		morse[i].nxt0 = -1;
		morse[i].nxt1 = -1;
		morse[i].letter = -1;
	}
	start0 = 0;
	start1 = 1;
	free_index = 2;		
    j = 0;
    while( (c = m_code[j++]) != -1 ) {
//                printf("%c",c);
//				li += c;
            cn = m_code[j++];
            if ( cn != 0)
                index = start1;
            else
                index = start0;
            while( (cn = m_code[j++]) != 2 ) {
                if ( cn != 0) { /* dash next */
                    nindex = morse[index].nxt1;
                    if ( nindex == -1) {
                        nindex = free_index++;
                        morse[index].nxt1 = nindex;
                    }
                }
                else        { /* dot next */
                    nindex = morse[index].nxt0;
                    if ( nindex == -1) {
                        nindex = free_index++;
                        morse[index].nxt0 = nindex;
                    }
                }
                index = nindex;
            } /* end while */
            /* end of letter */
            morse[index].letter = c;
    } /* end while, get next letter */
	//alert("morse table initialized");
}

initialize_morse_code();
max_trials = 1000000;

// bt table of letters plus blanks, so can handle word division, 27 characters
T1 = ""
T1 += "wPp4q4p@pP8RZ15rPArTqHR<PR3sPsX24YP@4Tp<PP4PqPtPsh"
T1 += ">p`Pr14P`<Pp1@tPs4|igW31qDP~~~s82zP~y1~w83dL8`PPp4"
T1 += "s1w8PX14|PRS:~r8RPPqPq4w82Pu4s8q1y2{iSV31B84P|PcNL"
T1 += "1|81p8y@p44tA444qP4y1p4~~v83dL8u8pPA4Vp<R@4P2pPApT"
T1 += "qP1pRpTqHR4PP2t144phRTAPA4Vp<R`4Pt2P9TsX_PePA4V5\\T"
T1 += "`hPq@p8R`4Pq4p4w4PriPW31rP~p4r4{4pPx@~pP~~~s8?dL8s"
T1 += "4}PP~@RQ~s8RP~8~4~xiPV31w8P@TP}PpP~~~t8PqPA4T44{P|"
T1 += "8olL8pQQ3<rP@42p<2@pPp2rTqP@rTqHR|LRTpP1p4p<RPPPq8"
T1 += "tPsh6PePA421\\P@]Pq@qRP4Ps4|iSW31~~~~~~~~s2t144~yP~"
T1 += "t8Pt4y8pP~~w@rPbHdP1q44p@pPs@@pLSs4p@uH@X@2xA44w4p"
T1 += "P@p5r5p4sAsPqPq22P4P1~w83dL84p2p4|h2Q24}Rp24w4u4s4"
T1 += "p<pR1x82Pu4~~piSV7aj<EP|Pk<MQtPv8MnMSwPx1rPa<MPx@p"
T1 += "44zPpPuP~83`L8s8rP@r4rPq8q2qPs4qHRpPR3sPuTpP@r4pRp"
T1 += "PpQp2q8YPs`LpAPsTp@8PwPr24w4slSW3QrP}3p4~@~qRPv2p5"
T1 += "P1~pPv8Px@{87dL8~~~~~~~~pPC<aRs4rPsdMHI3s<rPr2H6~t"
T1 += "Ps`DhARs4sAq4v21TpPH~w8CdL8FR8@4y@4p<WSO4u2s@p8RS8"
T1 += "4w8w8RPr2Yy8RPPpA44pPP@4p1pUp4|1wiWW3QBLDRs82pPt@:"
T1 += "L4p1x1qP1DMRx1q4tA444q@@P@wA4448R`TPA4q@pPAy@{8OnL"
T1 += ":s4rPp4q4p`pPwPs4rPwPsPw4sV6PA52PpP@r4q@Pq2p<PqP~{"
T1 += "Hp23p@~s4P~4D~x8p4Px@~~y2sP~r2~~{8RZ~s4rP~{iWW31~u"
T1 += "P~~~~~~x8P1@sPy2~~2D@t<~q82P@t4Pp4~|@q2~~~~~~~~qL4"
T1 += "2p4t4q8Rd4pnc[OpPTs2pP8pHt4s4pVp8R4PpADT4<RP42832C"
T1 += "rPt8RPPpIg[7]b`\\Pq4uAp4uOPS2y"

var bstd = [];
var max_score;
var l_alpha = "abcdefghijklmnopqrstuvwxyz";
var best_score;

function construct_table(){
    var i,n,index,c,ze,x,j,mask;
    // read T and put it into the working binary trigraph table: bstd
    n = 27*27*27;
    i = index = 0;

    ze = '0'.charCodeAt(0);
    while (i < n){
        //c = T.charCodeAt(index);
        c = T1.charCodeAt(index);
        index +=1
        //x = ord(c)-ord('0')
        x = c-ze;
        if (x > 63){
            x -= 63;
            //for j in range(6*x):
            for (j=0;j<6*x;j++){
                bstd[i] = 0;
                i += 1;
            }
        }
        else{
            mask = 1;
            while (mask < 64){
                if (mask & x ){
                    bstd[i] = 1;
                }
                else bstd[i] = 0;
                i += 1;
                mask += mask;
                if (i >= n)  break;
            }
        }
    }
}

construct_table();
//alert("table constructed");
function tsearch(ndex) {
    var c;
    var index,nindex,x;
	
    x = ndex;
    c = work_buffer[x++];
    if ( c== END_SYMBOL) { /* end of word */
            return(' ');
    }
    if ( c != 0 )
            index = start1;
    else
            index = start0;

    while( (c=work_buffer[x++])!= END_SYMBOL && x< code_len) {
            if (c != 0) {
                nindex = morse[index].nxt1;
                if ( nindex == -1) { /* no such letter*/
                        return(ERROR_SYMBOL);
                }
            }
            else {
                nindex = morse[index].nxt0;
                if ( nindex == -1) { /* no such letter*/
                        return(ERROR_SYMBOL);
                }}
            index = nindex;
    } /* end while */
    if ( morse[index].letter == -1 ) /* no corresponding letter*/
            return(ERROR_SYMBOL);
    return(morse[index].letter);
} /* end tsearch */

	
function get_trial_decrypt(){
        var i,j,k,x,y;
        var c1,c2,c3,c4;

	code_len = 0;
	for (x=0;x<buf_len;x++) {
		work_buffer[code_len++] = key[ buffer[x] ] ;
		
	} /* next x */
    if (work_buffer[code_len-1] != END_SYMBOL)
      	work_buffer[code_len++] = END_SYMBOL;
    /* now morse code translate into symbols*/
    x = plain_len = 0;
	plain_text = [];
    while( x<code_len) {
            if ( work_buffer[x] == END_SYMBOL) {
                    plain_text[plain_len++] = ' ';
                    x++;
                    if ( x>= code_len)
                            break;
            }
            plain_text[ plain_len++ ] = tsearch(x);
            while( work_buffer[x++] != END_SYMBOL && x <code_len);
    } /* end while */
} // end get trial decrypt

function get_score(buf_len){
	var score,i,n,cnt;

	lowerC = "abcdefghijklmnopqrstuvwxyz ";
	//lowerC = "abcdefghijklmnopqrstuvwxyz"; // temporarily leave out blanks
	get_trial_decrypt();
	// convert to form we can score
	for (i=0;i<plain_len;i++) {
		c = plain_text[i];
		if ( lowerC.indexOf(c) == -1 )
			score_buffer[i] = 27;
		else
			score_buffer[i] = lowerC.indexOf(c);
	}
			
	score = 0.0;
      /* penalties */
      for (j=0;j<plain_len;j++)
              if ( plain_text[j] == ERROR_SYMBOL)
                      score--;
      /* 2 blanks in a row */
      for (j=0;j<plain_len-1;j++)
              if ( plain_text[j] == ' ' &&
                      plain_text[j+1] == ' ' )
                      score--;
      /* trippled letters */
      for (j=0;j<plain_len-2;j++)
              if ( plain_text[j] == plain_text[j+1] &&
                      plain_text[j] == plain_text[j+2])
                      score--;
      /* single letters */
      for (j=0;j<plain_len-2;j++)
                if ( plain_text[j] == ' ' &&
                        ' ' == plain_text[j+2] ) {
                        c=plain_text[j+1];
                        if ( 'b' <= c && c <= 'z' && c != 'i' )
                        score--;
       }
                        
		//score *= 100;

    for (i=0;i<plain_len-2;i++) {
        if ( score_buffer[i] == 27 || score_buffer[i+1]==27||
        	score_buffer[i+2] == 27 ) continue;
        index = score_buffer[i]+27*score_buffer[i+1]
                            +27*27*score_buffer[i+2];
       	score += bstd[index];
   }
    return(score);
}	


var do_pollux_calc = function(cipher){ // return this function which can use the pseudo-global variables
	var  out_str,c,n,v,score,i,j,trial;
	var n1,n2,v1,v2,max_score,current_hc_score;
	var mut_count;
	var x,y,n3,n4;
	var noise_level,cycle_numb,sq_choice,c1,c2;
	var numb_accepted;
	//var max_trials; // now global
	var s;
    var crib_len;    
    var old_crib_score, crib_score;
	buffer = cipher; // make global closure var
	buf_len = buffer.length;

	//alert("pollux calc");
        //numb_decrypts = parseInt(document.getElementById('numb_decrypts').value );
		numb_decrypts = 50;
        //fudge_factor = parseFloat(document.getElementById('fudge').value );
		fudge_factor = 0.08;
        max_score = 0;
	
	key = [];
	for (i=0;i<10;i++) {
		key[i] = Math.floor(Math.random()*3);;
	}
	plain_text = [];
	cycle_limit = 25;
	//fudge_factor = 0.23; // now sent via post message
	begin_level = 1.0;
	noise_step = 5.0;
	noise_level = begin_level;
	cycle_numb = 0;
	max_score = current_hc_score = score = -100.0 * buf_len;
	//max_score = current_hc_score = score = 0;
	best_score = 0;
	//out_str = "test";
	//document.getElementById('output_area').value = out_str;	
	mut_count = 0;
	numb_accepted = 1;
	for (trial = 0;trial < max_trials;trial++){
		n1 = Math.floor(Math.random()*10);
		v1 = key[n1];
		key[n1]=Math.floor(Math.random()*3);
		score = get_score(buf_len);
		if ( score>max_score){
			max_score = score;
			x = score.toFixed(2);
			for (i=0;i<plain_text.length;i++){
				out_str += plain_text[i];
			}
			//out_str += "\nscore of plaintext: "+score.toFixed(2)+" on trial: "+trial;
			c = 1000*score/(plain_text.length-2);
			out_str = " \nnormalized pollux score is "+c.toFixed(0);
			best_score = c;
			//out_str += " normalized score is "+c.toFixed(2);
			//out_str += ", fudge factor: "+fudge_factor;
			//out_str += ", % accept: "+ (100.0*numb_accepted/(trial+1)).toFixed(2);
			//out_str += '\nKey:\n1234567890\n';
			//for (i=0;i<10;i++) // put zero's value last
				//out_str += symbols_3.charAt(key[(i+1)%10]);
			//document.getElementById('output_area').value = out_str;	
			//postMessage(out_str);
		}
       	if (score > current_hc_score-fudge_factor*buf_len/(noise_level)) {				
           	if (score != current_hc_score)
           		numb_accepted++;				
			current_hc_score = score;
            // score_sum += score;
            // accepted_count++;				
			}
		
		else {
			key[n1]=v1;
		}
		noise_level += noise_step;	
		if ( ++cycle_numb >= cycle_limit) {
			noise_level = begin_level;
			cycle_numb = 0;
		}
		if ( (trial%1000000)==0){
			v = 100.0*numb_accepted/(trial+1);
			v = v.toFixed(2);
			s = out_str+"\n\n(trial: "+trial+" % accepted: "+v+")";
			//postMessage(s);
		}
			
		
	} // next trial
	//return(out_str);
	return(best_score.toFixed(0));
}	
	
	//}
    return (do_pollux_calc); // return this function which can access pseudo_global variables
} // end pollux_calcs closure function



function do_id_test(){
	var s,x,num_dev,n;
    var test_index;
	var i,j,c,n,s,result;
    var str;
    db_element = document.puzzle.ciphertext.value;
	//db_element = one_blank_separator(db_element); // for ciphers with word division only.
	nc = convert_string(db_element)
	db_element = digits_only(db_element);
	if (nc.length < 2) {
		alert("Cipher has less than 2 digits!")
        //console.log("Cipher too short");
		return
	}
/*
0 Index of Coincidence times 1000 (IC): 
1 max IC for periods 1 to max,times 1000 (MIC): 
2 Digraphic Index of Coincidence, times 10000 (DIC): 
3 DIC for even numbered pairs, times 10000 (EDI): 
4 Long Repeat (percentage of 3 symbol repeats) (LR): 
5 length divisible by 2 (DIV_2): 
6 length divisible by 3 (DIV_3): 
7 length divisible by 5 (DIV_5): 
8 length divisible by 25 (DIV_25): 
9 Digital cipher that includes a zero (HAS_0): 
10 possible nihilist substitution period from 2 to max period (NSP): 
*/
if (nc.length <= 100)
    max_period = 10;
else
    max_period = 15;

test_values = [];

x = get_ic(nc)
test_index = 0;
test_values[test_index++] = Math.floor(x); 
x = get_max_periodic_ic(nc)   
test_values[test_index++] = Math.floor(x); 
x = get_dic(nc)
test_values[test_index++] = Math.floor(x);    
x = get_even_dic(nc)
test_values[test_index++] = Math.floor(x);    
x = get_LR(nc);
test_values[test_index++] = Math.floor(x);    
calc_length_attributes(nc.length);
test_index = 9;
c = 'N'
for (i=0;i<nc.length;i++)
	if ( nc[i] == 0 ){
		c = 'Y';
		break;
	}
test_values[test_index++] = c;
x = get_nsp(nc);
test_values[test_index++] = x;

/*
new numerical stats:
11 minimum of maximum tridigital digit separator distances (TRI_SEP)
12 monome-dinome smallest difference between IC and standard english IC of 0.065 (MD_diff)
13 does cipher contain a 9 ? (HAS_9)
14 maximum digit at an even position (MAX_EVEN)
15 best Pollux normalized hill-climbing score with scoring by 27 character binary trigraphs (POLLUX_score)
*/
result = get_TRI_SEP(nc);
test_values[test_index++] = result[0];
s = get_MD_diff(db_element);
test_values[test_index++] = s;
s = get_has_9(nc);
test_values[test_index++] = s;
x = get_max_even(nc)
test_values[test_index++] = Math.floor(x);    
do_pollux_calc = pollux_calcs(); // returns a function and initializes scoring table
s = do_pollux_calc(nc);   
test_values[test_index++] = s;

//document.puzzle.cipherstats.value = test_values;




s = normalize_test_values();

var result = neural_net_get_id(s);
s = "Top cipher type is:\n"
s += cipher_name_normalized_order[ result[0]	]+'\n\n';
s += 'Top  cipher types were:\n';
for (i=0;i<5;i++){
    s += result[1][i][0]+' '+result[1][i][1].toFixed(2)+'\n';
}

s += display_new_stats;
document.puzzle.cipherstats.value = s


}
/*
Average for index IC is 58.58
Average for index MIC is 71.59
Average for index MKA is 88.98
Average for index DIC is 50.59
Average for index EDI is 58.85
Average for index LR is 12.53
Average for index ROD is 45.48
Average for index LDI is 427.62
Average for index SDD is 103.70
Average for index A_LDI is 504.13
Average for index B_LDI is 510.24
Average for index P_LDI is 491.42
Average for index S_LDI is 314.89
Average for index V_LDI is 524.02
Average for index NOMOR is 130.23
Average for index RDI is 244.75
Average for index PTX is 231.48
Average for index NIC is 44.55
Average for index PHIC is 39.09
Average for index BDI is 211.64
Average for index CDD is 188.70
Average for index SSTD is 25.25
Average for index MPIC is 46.57
Average for index ROUTE_BSTD is 0.15
Average for index MYSZ_BSTD is 0.29
Average for index VIG_VAR_DC is 0.31
Average for index STD_DC is 0.39
Average for index CHI_SQ is 243.00
Average for index PROGKEY_LDI is 502.50
ave_GRO = 429.58

Standard deviation for index IC is 27.21
Standard deviation for index MIC is 31.62
Standard deviation for index MKA is 35.10
Standard deviation for index DIC is 56.26
Standard deviation for index EDI is 66.68
Standard deviation for index LR is 10.48
Standard deviation for index ROD is 12.65
Standard deviation for index LDI is 201.66
Standard deviation for index SDD is 54.85
Standard deviation for index A_LDI is 269.28
Standard deviation for index B_LDI is 270.81
Standard deviation for index P_LDI is 260.55
Standard deviation for index S_LDI is 331.93
Standard deviation for index V_LDI is 278.26
Standard deviation for index NOMOR is 90.12
Standard deviation for index RDI is 263.10
Standard deviation for index PTX is 244.41
Standard deviation for index NIC is 26.49
Standard deviation for index PHIC is 23.68
Standard deviation for index BDI is 173.01
Standard deviation for index CDD is 110.09
Standard deviation for index SSTD is 24.23
Standard deviation for index MPIC is 27.32
Standard deviation for index ROUTE_BSTD is 0.21
Standard deviation for index MYSZ_BSTD is 0.26
Standard deviation for index VIG_VAR_DC is 0.17
Standard deviation for index STD_DC is 0.30
Standard deviation for index CHI_SQ is 132.09
Standard deviation for index PROGKEY_LDI is 266.79
std_GRO = 255.65
*/


var numerical_attributes = [0,1,2,3,4,5,6,7,8,22,23,24,25,26,27,28,29,30,31,33,34,35,36,38,39,41,42,43,44,46];

numerical_averages = [ 58.58,71.59,88.98,50.59,58.85,12.53,45.48,427.62,103.70,504.13,
510.24,491.42,314.89,524.02,130.23,244.75,231.48,44.55,39.09,211.64,188.70,25.25,46.57,0.15,0.29,0.31,0.39,243.00,502.50,429.58];
numerical_std_devs = [27.21,31.62,35.10,56.26,66.68,10.48,12.65,201.66,54.85,269.28,
270.81,260.55,331.93,278.26,90.12,263.10,244.41,26.49,23.68,173.01,110.09,24.23,27.32,0.21,0.26,0.17,0.30,132.09,266.79,255.65]; 


var selected_stat_array = [true,true,false,true,true,true,false,false,false,false,true,true,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,]


function normalize_test_values(){
    var i,j,k,n,c,s;
	
	
	
	var original_index = [];
	
	for (j=0;j<48;j++){
		if ( j==9) continue; // skip cipher type
		if (selected_stat_array[j] )
			original_index.push(j);
	}
	
    normalized_test_values = [];

	for (i=0;i<11;i++){
	        if (numerical_attributes.indexOf( original_index[i] ) != -1) {// numerical value
				n = (test_values[i] - numerical_averages[ original_index[i] ])/numerical_std_devs[ original_index[i] ];
				normalized_test_values.push(Math.round(n*100)/100);
			}
			else if (test_values[i] == 'Y'){
				//s += 1.0
				normalized_test_values[i] = 1.0
			}
			else if (test_values[i] == 'N'){
				//s += 0.0
				normalized_test_values[i] = 0.0;
			}

	}
	
var ave_TRI_SEP = 37;
var std_dev_TRI_SEP = 29;

var ave_MD_diff = 0.2588;
var std_dev_MD_diff = 0.4008;

// for HAS_9 just use 0 for N and 1 for Y

var ave_MAX_EVEN = 7;
var std_dev_MAX_EVEN = 2;;

var ave_POLLUX_score = 382;
var std_dev_POLLUX_score = 179;;

var TRI_SEP;
var MD_diff;
var HAS_9;
var MAX_EVEN;
var POLLUX_score;

display_new_stats = '\nNew normalized numerical stats:\n'; // global variable
    TRI_SEP = test_values[11];
	norm = (TRI_SEP-ave_TRI_SEP) / std_dev_TRI_SEP;
	normalized_test_values.push( norm.toFixed(2) );
	display_new_stats += 'Smallest maximum digit separation (TRI-SEP): '+norm.toFixed(2)+'\n';

    MD_diff = test_values[12];;
	norm = (MD_diff-ave_MD_diff) / std_dev_MD_diff;
	normalized_test_values.push( norm.toFixed(2) );
	display_new_stats += 'Smallest difference bewteen monome-dinome labels IC and 0.65 (MD-diff): '+norm.toFixed(2)+'\n';
	
	HAS_9 = test_values[13];
	if (HAS_9 == 'N'){
		normalized_test_values.push( '0.0' );
		display_new_stats += 'HAS_9 N: 0.0\n';		
	}
	else {
		normalized_test_values.push( '1.0' );
		display_new_stats += 'HAS_9 Y: 1.0\n';		
	}
	
    MAX_EVEN = test_values[14];
	norm = (MAX_EVEN-ave_MAX_EVEN) / std_dev_MAX_EVEN;
	normalized_test_values.push( norm.toFixed(2) );
	display_new_stats += 'Maximum digit at an even position (MAX_EVEN): '+norm.toFixed(2)+'\n';
	
    POLLUX_score = test_values[15];
	norm = (POLLUX_score-ave_POLLUX_score) / std_dev_POLLUX_score;
	normalized_test_values.push( norm.toFixed(2) );
	display_new_stats += 'Pollux hill-climbing score for 27 char binary trigraphs (POLLUX_score): '+norm.toFixed(2)+'\n';	
	/*
	s = "[";
	for (i=0;i<normalized_test_values.length;i++)
		s += normalized_test_values[i]
	s += ']';
*/
    return(normalized_test_values);
	//return(s);
    
}    




</SCRIPT>
</HEAD>
<BODY bgcolor="Silver" onload = "neural_net_setup()" >
<Center>
<H2>Neural Net ID test, numerical ciphers</H2>
</Center>


<FORM name=puzzle>
Cipher: <BR><TEXTAREA id="ciphertext" styLe="font-family:monospace" spellcheck="false" name=ciphertext rows=8 cols=85>
</TEXTAREA><BR>
Stats: <BR><TEXTAREA id="cipherstats" styLe="font-family:monospace" name=cipherstats rows=11 cols=85></TEXTAREA><BR>
<BR><BR>
<!---
<INPUT onclick=do_compare(); type=button value="Compare" >
-->
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<INPUT onclick=do_id_test(); type=button value="ID test" >

<INPUT onclick=do_clear(); type=button value="Clear" >

<!--
&nbsp &nbsp &nbsp &nbsp Maximum period to try: <input type = text name=period_entry  id="period_entry" size = 3 value="10" >
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Hidden unit function: &nbsp; &nbsp;
sigmoid <input type="radio" name="r_buttons" id = "sigmoid" >
&nbsp;&nbsp;
relu <input type="radio" name="r_buttons" id = "relu" checked>
-->
</FORM>
<br>
<BR> <B>Directions:</B> Type or paste unknown numerical cipher into cipher box. Click ID test button. 
Results appear in Stats box.(may take quite awhile for results to appear) <BR>
 
</BODY></HTML>
